/**
 * Combined, minified redistributable GNU ease.js file.
 * <http://www.gnu.org/software/easejs/>
 * Copyright (C) 2010, 2011, 2012, 2013, 2014 Free Software Foundation, Inc.
 * @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&dn=gpl-3.0.txt GPL-v3-or-Later
 */
'use strict';var easejs={};
(function(D,j){function A(c){throw Error("Assertion failed: "+(c||"(no failure message)"));}var g={},f=function(c){var c=("/"===c.substr(0,1)?c:j+"/"+c).replace(/([^\/]+\/\.\.\/|\.\/|^\/)/g,""),a=g[c];if(void 0===a)throw"[ease.js] Undefined module: "+c;return a.exports};(function(c){function a(){if(!(this instanceof a))return new a;this.___$$id$$=e+d(1E8*b())}c.exports={};j="util/symbol";var b=Math.random,d=Math.floor,e=" "+String.fromCharCode(d(10*b())%31+1)+"$";a.prototype={toString:function(){return this.___$$id$$}};
c.exports=a})(g["util/symbol/FallbackSymbol"]={},".");(function(c){function a(){if(!(this instanceof a))return new a;this._alt={}}c.exports={};j="util";(0,eval)("var _the_global=this");a.expose=function(){return _the_global};a.prototype={provideAlt:function(a,d){if(!(void 0!==_the_global[a]||void 0!==this._alt[a]))return this._alt[a]=d(),this},get:function(a){return void 0!==this._alt[a]?this._alt[a]:_the_global[a]}};c.exports=a})(g["util/Global"]={},".");(function(c){c.exports={};j="util";var a=
f("./symbol/FallbackSymbol"),b=f("./Global").expose();c.exports=b.Symbol||a})(g["util/Symbol"]={},".");(function(c){c=c.exports={};j=".";var a={"public":1,"protected":2,"private":4,"static":8,"abstract":16,"const":32,virtual:64,override:128,proxy:256,weak:512},b={amods:a["public"]|a["protected"]|a["private"],virtual:a["abstract"]|a.virtual};c.kvals=a;c.kmasks=b;c.parseKeywords=function(d){var e=d,c=[],h=0,k={};if(1!==(c=(""+d).split(/\s+/)).length){e=c.pop();for(d=c.length;d--;){var E=c[d],r=a[E];
if(!r)throw Error("Unexpected keyword for '"+e+"': "+E);k[E]=!0;h|=r}}e.match(/^_[^_]/)&&!(h&b.amods)&&(k["private"]=!0,h|=a["private"]);return{name:e,keywords:k,bitwords:h}}})(g.prop_parser={},".");(function(c){function a(a){throw a;}function b(a,b,d){for(var e=d.length;e--;)null===d[e].match(/^[a-z_][a-z0-9_]*$/i)&&a(SyntaxError("Member "+b+" contains invalid parameter '"+d[e]+"'"))}function d(){return h?function(a,b,d){Object.defineProperty(a,b,{value:d,enumerable:!1,writable:!1,configurable:!1})}:
function(a,b,d){a[b]=d}}var e=c.exports={};j=".";var i=f("./prop_parser").parseKeywords,h;a:{if("function"===typeof Object.defineProperty)try{Object.defineProperty({},"x",{});h=!0;break a}catch(k){}h=!1}e.Global=f("./util/Global");e.freeze="function"===typeof Object.freeze?Object.freeze:function(){};e.definePropertyFallback=function(a){if(void 0===a)return!h;h=!a;e.defineSecureProp=d();return e};e.defineSecureProp=d();e.clone=function r(a,b){b=!!b;if(a instanceof Array){if(!b)return a.slice(0);for(var d=
[],e=0,c=a.length;e<c;e++)d.push(r(a[e],b));return d}if("function"!==typeof a&&a instanceof Object){d={};e=Object.prototype.hasOwnProperty;for(c in a)e.call(a,c)&&(d[c]=b?r(a[c]):a[c]);return d}return a};e.copyTo=function(a,b,d){var d=!!d,c;if(!(a instanceof Object)||!(b instanceof Object))throw TypeError("Must provide both source and destination objects");if(h)for(var i in b)c=Object.getOwnPropertyDescriptor(b,i),c.get||c.set?Object.defineProperty(a,i,c):a[i]=d?e.clone(b[i],!0):b[i];else for(i in b)a[i]=
d?e.clone(b[i],!0):b[i];return a};e.propParse=function(d,c,k){var f=function(){},g=c.each||void 0,j=c.property||f,n=c.method||f,f=c.getset||f,m=c.keywordParser||i,u=c._throw||a,v=Object.prototype.hasOwnProperty,o={},y="",o={},z=null,w=!1,x=!1,F;for(F in d)if(v.call(d,F)){if(h)y=Object.getOwnPropertyDescriptor(d,F),w=y.get,x=y.set;z="function"===typeof w?void 0:d[F];o=m(F)||{};y=o.name||F;o=o.keywords||{};if(c.assumeAbstract||o["abstract"]&&!o.override)o["abstract"]=!0,z instanceof Array||u(TypeError("Missing parameter list for abstract method: "+
y)),b(u,y,z),z=e.createAbstractMethod.apply(this,z);g&&g.call(k,y,z,o);w||x?f.call(k,y,w,x,o):"function"===typeof z||o.proxy?n.call(k,y,z,e.isAbstractMethod(z),o):j.call(k,y,z,o)}};e.createAbstractMethod=function(a){for(var b=[],d=arguments.length;d--;)b[d]=arguments[d];d=function(){throw Error("Cannot call abstract method");};e.defineSecureProp(d,"abstractFlag",!0);e.defineSecureProp(d,"definition",b);e.defineSecureProp(d,"__length",arguments.length);return d};e.isAbstractMethod=function(a){return"function"===
typeof a&&!0===a.abstractFlag?!0:!1};e.arrayShrink=function(a){for(var b=[],d=0,e=a.length;d<e;d++){var c=a[d];void 0!==c&&b.push(c)}return b};e.getOwnPropertyDescriptor=h&&Object.getOwnPropertyDescriptor||function(a,b){return!Object.prototype.hasOwnProperty.call(a,b)?void 0:{get:void 0,set:void 0,writable:!0,enumerable:!0,configurable:!0,value:a[b]}};e.getPrototypeOf=Object.getPrototypeOf||function(){};e.getPropertyDescriptor=function(a,b,d){var d=!!d,c=e.getOwnPropertyDescriptor(a,b),a=e.getPrototypeOf(a);
return!c&&a&&(!d||e.getPrototypeOf(a))?e.getPropertyDescriptor(a,b,d):c};e.defineSecureProp(e.getPropertyDescriptor,"canTraverse",Object.getPrototypeOf?!0:!1)})(g.util={},".");(function(c){function a(b){if(!(this instanceof a))return new a(b);if(!(b instanceof Error))throw TypeError("Must provide exception to wrap");Error.prototype.constructor.call(this,b.message);this.message=b.message;this.name="Warning";this._error=b;this.stack=b.stack&&b.stack.replace(/^.*?\n+/,this.name+": "+this.message+"\n")}
c.exports={};j="warn";a.prototype=Error();a.prototype.constructor=a;a.prototype.name="Warning";a.prototype.getError=function(){return this._error};c.exports=a})(g["warn/Warning"]={},".");(function(c){function a(){if(!(this instanceof a))return new a}c.exports={};j="warn";a.prototype={handle:function(){}};c.exports=a})(g["warn/DismissiveHandler"]={},".");(function(c){function a(b){if(!(this instanceof a))return new a(b);this._console=b||{}}c.exports={};j="warn";a.prototype={handle:function(a){var d=
this._console.warn||this._console.log;d&&d.call(this._console,"Warning: "+a.message)}};c.exports=a})(g["warn/LogHandler"]={},".");(function(c){function a(){if(!(this instanceof a))return new a}c.exports={};j="warn";a.prototype={handle:function(a){throw a.getError();}};c.exports=a})(g["warn/ThrowHandler"]={},".");(function(c){c.exports={};j=".";c.exports={Warning:f("./warn/Warning"),DismissiveHandler:f("./warn/DismissiveHandler"),LogHandler:f("./warn/LogHandler"),ThrowHandler:f("./warn/ThrowHandler")}})(g.warn=
{},".");(function(c){function a(a,b){try{if(b instanceof a)return!0}catch(d){}return!1}function b(a,b,d){b=this.defs;if(!0===z[a])throw Error(a+" is reserved");if(o.call(b,a)&&!d.weak&&!b[a].weak)throw Error("Cannot redefine method '"+a+"' in same declaration");b[a]=d}function d(a,b,d){this._cb._memberBuilder.buildProp(k(d)?this.static_members.props:this.prop_init,null,a,b,d,this.base)}function e(a,b,d,e){var c=k(e)?this.static_members.methods:this.members,i=k(e)?this.staticInstLookup:n.getMethodInstance;
this._cb._memberBuilder.buildGetterSetter(c,null,a,b,d,e,i,this.class_id,this.base)}function i(a,b,d,e){var c=k(e),i=c?this.static_members.methods:this.members,c=c?this.staticInstLookup:n.getMethodInstance;if(!0===w[a]&&(e["protected"]||e["private"]))throw TypeError(a+" must be public");this._cb._memberBuilder.buildMethod(i,null,a,b,e,c,this.class_id,this.base,this.state)&&(d?(this.abstract_methods[a]=!0,this.abstract_methods.__length++):o.call(this.abstract_methods,a)&&!1===d&&(delete this.abstract_methods[a],
this.abstract_methods.__length--),e.virtual&&(this.virtual_members[a]=!0))}function h(a,b,d,e){if(a.___$$abstract$$){if(!e&&0===d.__length)throw TypeError("Class "+(b||"(anonymous)")+" was declared as abstract, but contains no abstract members");}else if(0<d.__length)if(e)a.___$$abstract$$=!0;else throw TypeError("Class "+(b||"(anonymous)")+" contains abstract members and must therefore be declared abstract");}function k(a){return a["static"]||a["const"]?!0:!1}function E(a,b){var d=b.__cid?n.getMeta(b):
void 0;return d?a[x].meta=m.clone(d,!0):a[x].meta={implemented:[]}}function g(a,b){m.defineSecureProp(a,"__iid",b)}function t(a){var b=function(){};b.prototype=a;m.defineSecureProp(a,x,{});a[x].vis=new b}function l(a){var b=function(b){return c.exports.isInstanceOf(b,a)};m.defineSecureProp(a,"isInstanceOf",b);m.defineSecureProp(a,"isA",b)}function p(a,b){var d=0<b.__length?!0:!1;m.defineSecureProp(a,"isAbstract",function(){return d})}function q(a,b){m.defineSecureProp(a,"__cid",b);m.defineSecureProp(a.prototype,
"__cid",b)}function s(a,b){a.___$$final$$=!!b.___$$final$$;a.___$$abstract$$=!!b.___$$abstract$$;b.___$$final$$=b.___$$abstract$$=void 0}var n=c.exports={};j=".";var m=f("./util"),u=f("./warn").Warning,v=f("./util/Symbol"),o=Object.prototype.hasOwnProperty,y=!1===Object.prototype.propertyIsEnumerable.call({toString:function(){}},"toString")?!0:!1,z={__initProps:!0,constructor:!0},w={__construct:!0,__mixin:!0,toString:!0,__toString:!0},x=v();c.exports=n=function(a,b,d){if(!(this instanceof n))return new c.exports(a,
b,d);this._warnHandler=a;this._memberBuilder=b;this._visFactory=d;this._instanceId=this._classId=0;this._spropInternal=this._extending=!1};n.ClassBase=function(){};m.defineSecureProp(n.ClassBase,"__cid",0);n.ClassBase.$=function(a,b){if(void 0!==b)throw ReferenceError("Cannot set value of undeclared static property '"+a+"'");};n.getReservedMembers=function(){return m.clone(z,!0)};n.getForcedPublicMethods=function(){return m.clone(w,!0)};n.getMeta=function(a){return(a[x]||{}).meta||null};n.isInstanceOf=
function(b,d){return!b||!d?!1:!!(b.__isInstanceOf||a)(b,d)};n.prototype.build=function(a,b){var d=this;this._extending=!0;var e=arguments,c=e.length,i=(0<c?e[c-1]:0)||{},k=(1<c?e[c-2]:0)||n.ClassBase,e=this._getBase(k),c="",w=!1,f=this._memberBuilder.initMembers(),g=this._memberBuilder.initMembers(e),j={methods:this._memberBuilder.initMembers(),props:this._memberBuilder.initMembers()},w=n.getMeta(k)||{},r=m.clone(w.abstractMethods)||{__length:0},z=m.clone(w.virtualMembers)||{};if(!0===k.___$$final$$)throw Error("Cannot extend final class "+
(k[x].meta.name||"(anonymous)"));(c=i.__name)&&delete i.__name;void 0!==(w=i.___$$auto$abstract$$)&&delete i.___$$auto$abstract$$;if(y&&i.toString!==Object.prototype.toString)i.__toString=i.toString;this._classId++;void 0===(e[x]||{}).vis&&this._discoverProtoProps(e,f);try{this.buildMembers(i,this._classId,k,f,{all:g,"abstract":r,"static":j,virtual:z},function(){return l.___$$svis$$})}catch(t){if(t instanceof u)this._warnHandler.handle(t);else throw t;}e.___$$parent$$=k.prototype;var l=this.createCtor(c,
r,g);this.initStaticVisibilityObj(l);var o=this,v=function(a,b){o.attachStatic(a,j,k,b)};v(l,!1);this._attachPropInit(e,f,g,l,this._classId);l.prototype=e;l.prototype.constructor=l;l.___$$props$$=f;l.___$$methods$$=g;l.___$$sinit$$=v;s(l,i);h(l,c,r,w);m.defineSecureProp(e,"__self",l.___$$svis$$);w=E(l,k);w.abstractMethods=r;w.virtualMembers=z;w.name=c;p(l,r);q(l,this._classId);l.asPrototype=function(){d._extending=!0;var a=l();d._extending=!1;return a};this._extending=!1;return l};n.prototype._getBase=
function(a){switch(typeof a){case "function":return new a;case "object":return a}throw TypeError("Must extend from Class, constructor or object");};n.prototype._discoverProtoProps=function(a,b){var d=Object.hasOwnProperty,e;for(e in a){var c=a[e];d.call(a,e)&&"function"!==typeof c&&this._memberBuilder.buildProp(b,null,e,c,{})}};n.prototype.buildMembers=function(a,c,h,w,k,E){var y={_cb:this,prop_init:w,class_id:c,base:h,staticInstLookup:E,defs:{},state:{},members:k.all,abstract_methods:k["abstract"],
static_members:k["static"],virtual_members:k.virtual},f={each:b,property:d,getset:e,method:i};if(a.___$$parser$$){var g=a.___$$parser$$;delete a.___$$parser$$;c=function(a,b){f[a]=function(){for(var d=[],e=arguments.length;e--;)d[e]=arguments[e];d.push(b);g[a].apply(y,d)}};g.each&&c("each",f.each);g.property&&c("property",f.property);g.getset&&c("getset",f.getset);g.method&&c("method",f.method)}m.propParse(a,f,y);this._memberBuilder.end(y.state)};n.prototype.createCtor=function(a,b,d){a=0===b.__length?
this.createConcreteCtor(a,d):this.createAbstractCtor(a);m.defineSecureProp(a,x,{});return a};n.prototype.createConcreteCtor=function(a,b){function d(){if(!(this instanceof d))return e=arguments,new d;t(this);this.__initProps();if(!c._extending){g(this,++c._instanceId);var i="function"===typeof this.___$$ctor$pre$$;i&&d.prototype.hasOwnProperty("___$$ctor$pre$$")&&(this.___$$ctor$pre$$(x),i=!1);"function"===typeof this.__construct&&this.__construct.apply(this,e||arguments);i&&this.___$$ctor$pre$$(x);
"function"===typeof this.___$$ctor$post$$&&this.___$$ctor$post$$(x);e=null;l(this);if(!o.call(b["public"],"toString"))this.toString=b["public"].__toString||(a?function(){return"#<"+a+">"}:function(){return"#<anonymous>"})}}var e=null,c=this;d.toString=a?function(){return a}:function(){return"(Class)"};return d};n.prototype.createAbstractCtor=function(a){var b=this,d=function(){if(!b._extending)throw Error("Abstract class "+(a||"(anonymous)")+" cannot be instantiated");};d.toString=a?function(){return a}:
function(){return"(AbstractClass)"};return d};n.prototype._attachPropInit=function(a,b,d,e,c){var i=this;m.defineSecureProp(a,"__initProps",function(e){var e=!!e,h=a.___$$parent$$,k=this[x].vis,h=h&&h.__initProps;"function"===typeof h&&h.call(this,!0);h=i._visFactory.createPropProxy(this,k,b["public"]);k=k[c]=i._visFactory.setup(h,b,d);e||m.defineSecureProp(k,"__inst",this)})};n.prototype.initStaticVisibilityObj=function(a){var b=this,d=function(){};d.prototype=a;d=new d;a.___$$svis$$=d;d.$=function(){b._spropInternal=
!0;var d=a.$.apply(a,arguments);b._spropInternal=!1;return d}};n.prototype.attachStatic=function(a,b,d,e){var c=b.methods,i=b.props,h=this;(b=d.___$$sinit$$)&&b(a,!0);if(!e)a.___$$sprops$$=i,m.defineSecureProp(a,"$",function(b,e){var c=!1,k=this.___$$sprops$$?this:a,w=k!==a,c=o.call(i["public"],b)&&"public";!c&&h._spropInternal&&(c=o.call(i["protected"],b)&&"protected"||!w&&o.call(i["private"],b)&&"private");if(!1===c)return(d.__cid&&d.$||n.ClassBase.$).apply(k,arguments);c=i[c][b];if(1<arguments.length){if(c[1]["const"])throw TypeError("Cannot modify constant property '"+
b+"'");c[0]=e;return k}return c[0]});m.copyTo(a,c["public"],!0);m.copyTo(a.___$$svis$$,c["protected"],!0);e||m.copyTo(a.___$$svis$$,c["private"],!0)};n.getMethodInstance=function(a,b){if(void 0===a)return null;var d=a[x],e;return a.__iid&&d&&(e=d.vis)?e[b]:null}})(g.ClassBuilder={},".");(function(c){var a=c.exports={};j=".";c.exports=a=function(b){if(!(this instanceof a))return new c.exports(b);this._factory=b};a.prototype.wrapMethod=function(a,d,e,c,h,k){return this._factory(a,d,e,c,h,k)}})(g.MethodWrapperFactory=
{},".");(function(c){c=c.exports={};j=".";c.standard={wrapOverride:function(a,b,d,e){var c=function(){var c=e(this,d)||this||{},i=void 0,E=c.__super;c.__super=b;i=a.apply(c,arguments);c.__super=E;return i===c?this:i};c["super"]=b;return c},wrapNew:function(a,b,d,e){return function(){var b=e(this,d)||this,c=void 0,c=a.apply(b,arguments);return c===b?this:c}},wrapProxy:function(a,b,d,e,c,h){var k=h&&h["static"],b=function(){var b=e(this,d)||this,h=void 0,b=k?b.$(a):b[a];if(!(null!==b&&"object"===typeof b&&
"function"===typeof b[c]))throw TypeError("Unable to proxy "+c+"() call to '"+a+"'; '"+a+"' is undefined or '"+c+"' is not a function.");h=b[c].apply(b,arguments);return h===b?this:h};b.__length=NaN;return b}}})(g.MethodWrappers={},".");(function(c){function a(a){return function(){return this.___$$super$$.prototype[a].apply(this.___$$pmo$$,arguments)}}function b(a,b,e){if(b["private"])return(b["public"]||b["protected"])&&d(e),a["private"];if(b["protected"])return(b["public"]||b["private"])&&d(e),
a["protected"];(b["private"]||b["protected"])&&d(e);return a["public"]}function d(a){throw TypeError("Only one access modifier may be used for definition of '"+a+"'");}function e(a,b,d){for(var c=k.length,i=null;c--;)if(i=h.getPropertyDescriptor(a[k[c]],b,!0))return{get:i.get,set:i.set,member:i.value};return void 0!==d?(a=d.___$$methods$$,c=d.___$$props$$,d=((d.prototype||{}).___$$parent$$||{}).constructor,a&&e(a,b,d)||c&&e(c,b,d)||null):null}var i=c.exports={};j=".";var h=f("./util"),k=["public",
"protected","private"];c.exports=function(a,b,d,e){if(!(this instanceof c.exports))return new c.exports(a,b,d,e);this._wrapMethod=a;this._wrapOverride=b;this._wrapProxy=d;this._validate=e};i=c.exports.prototype;i.initMembers=function(a,b,d){return{"public":a||{},"protected":b||{},"private":d||{}}};i.buildMethod=function(d,c,i,h,k,f,g,j,m){var u=this._methodKeywordDefaults,u=(c=(j=e(d,i,j))?j.member:null)&&(c.___$$keywords$$||u),d=b(d,k,i);this._validate.validateMethod(i,h,k,j,u,m);if(k.proxy&&(!c||
!k.weak))d[i]=this._createProxy(h,f,g,i,k);else if(c){if(k.weak&&!u["abstract"])return!1;if(k.override||u["abstract"])m=k["abstract"]?a(i):c,d[i]=this._overrideMethod(m,h,f,g);else throw Error("Method hiding not yet implemented (we should never get here; bug).");}else d[i]=k["abstract"]||k["private"]?h:this._overrideMethod(null,h,f,g);d[i].___$$keywords$$=k;return!0};i._methodKeywordDefaults={virtual:!0};i.buildProp=function(a,d,c,i,h,k){k=(d=e(a,c,k))?d.member:null;this._validate.validateProperty(c,
i,h,d,k?k[1]:null);b(a,h,c)[c]=[i,h]};i.buildGetterSetter=function(a,d,c,i,h,k,f,g,j){d=e(a,c,j);this._validate.validateGetterSetter(c,{},k,d,d&&d.get?d.get.___$$keywords$$:null);if(i)i=this._overrideMethod(null,i,f,g),i.___$$keywords$$=k;Object.defineProperty(b(a,k,c),c,{get:i,set:h?this._overrideMethod(null,h,f,g):h,enumerable:!0,configurable:!1})};i._createProxy=function(a,b,d,e,c){return this._wrapProxy.wrapMethod(a,null,d,b,e,c)};i._overrideMethod=function(a,b,d,e){var c=null,c=(a?this._wrapOverride:
this._wrapMethod).wrapMethod(b,a,e,d||function(){});h.defineSecureProp(c,"__length",b.__length||b.length);return c};i._getVisibilityValue=function(a){return a["protected"]?1:a["private"]?2:0};i.end=function(a){this._validate&&this._validate.end(a)}})(g.MemberBuilder={},".");(function(c){var a=c.exports={};j=".";c.exports=a=function(a){if(!(this instanceof c.exports))return new c.exports(a);this._warningHandler=a||function(){}};a.prototype._initState=function(a){if(a.__vready)return a;a.warn={};a.__vready=
!0;return a};a.prototype.end=function(a){for(var d in a.warn){var e=a.warn[d],c;for(c in e)this._warningHandler(e[c])}a.__vready=!1};a.prototype.validateMethod=function(a,d,e,c,h,k){this._initState(k);var f=c?c.member:null;if(e["abstract"]&&e["private"])throw TypeError("Method '"+a+"' cannot be both private and abstract");if(e["const"])throw TypeError("Cannot declare method '"+a+"' as constant; keyword is redundant");if(e.virtual&&e["static"])throw TypeError("Cannot declare static method '"+a+"' as virtual");
if(c&&(c.get||c.set))throw TypeError("Cannot override getter/setter '"+a+"' with method");if(e.proxy){if("string"!==typeof d)throw TypeError("Cannot declare proxy method '"+a+"'; string value expected");if(e["abstract"])throw TypeError("Proxy method '"+a+"' cannot be abstract");}if(f){if(h["private"])throw TypeError("Private member name '"+a+"' conflicts with supertype");if("function"!==typeof f)throw TypeError("Cannot override property '"+a+"' with method");if(e.override&&!h.virtual){if(!e["abstract"])throw TypeError("Cannot override non-virtual method '"+
a+"'");if(!h["abstract"])throw TypeError("Cannot perform abstract override on non-abstract method '"+a+"'");}if(e["abstract"]&&!e.weak&&!h["abstract"])throw TypeError("Cannot override concrete method '"+a+"' with abstract method");c=void 0===f.__length?f.length:f.__length;d=void 0===d.__length?d.length:d.__length;e.proxy&&(d=NaN);e.weak&&!h["abstract"]&&(f=c,c=d,d=f);if(d<c)throw TypeError("Declaration of method '"+a+"' must be compatible with that of its supertype");if(this._getVisibilityValue(h)<
this._getVisibilityValue(e))throw TypeError("Cannot de-escalate visibility of method '"+a+"'");if(!e.override&&!h["abstract"]&&!e.weak)throw TypeError("Attempting to override method '"+a+"' without 'override' keyword");e.weak&&h.override&&delete (k.warn[a]||{}).no}else if(e.override)(k.warn[a]=k.warn[a]||{}).no=Error("Method '"+a+"' using 'override' keyword without super method")};a.prototype.validateProperty=function(a,d,e,c,h){if(d=c?c.member:null){if(h["private"])throw TypeError("Private member name '"+
a+"' conflicts with supertype");if("function"===typeof d)throw new TypeError("Cannot override method '"+a+"' with property");if(this._getVisibilityValue(h)<this._getVisibilityValue(e))throw TypeError("Cannot de-escalate visibility of property '"+a+"'");}if(c&&(c.get||c.set))throw TypeError("Cannot override getter/setter '"+a+"' with property");if(e["abstract"])throw TypeError("Property '"+a+"' cannot be declared as abstract");if(e["static"]&&e["const"])throw TypeError("Static keyword cannot be used with const for property '"+
a+"'");if(e.virtual)throw TypeError("Cannot declare property '"+a+"' as virtual");};a.prototype.validateGetterSetter=function(a,d,e,c,h){d=c?c.member:null;c=c&&(c.get||c.set)?!0:!1;if(e["abstract"])throw TypeError("Cannot declare getter/setter '"+a+"' as abstract");if(e["const"])throw TypeError("Cannot declare const getter/setter '"+a+"'");if(e.virtual&&e["static"])throw TypeError("Cannot declare static method '"+a+"' as virtual");if(d||c){if(h&&h["private"])throw TypeError("Private member name '"+
a+"' conflicts with supertype");if(!c)throw TypeError("Cannot override method or property '"+a+"' with getter/setter");if(!h||!h.virtual)throw TypeError("Cannot override non-virtual getter/setter '"+a+"'");if(!e.override)throw TypeError("Attempting to override getter/setter '"+a+"' without 'override' keyword");if(this._getVisibilityValue(h||{})<this._getVisibilityValue(e))throw TypeError("Cannot de-escalate visibility of getter/setter '"+a+"'");}else e.override&&this._warningHandler(Error("Getter/setter '"+
a+"' using 'override' keyword without super getter/setter"))};a.prototype._getVisibilityValue=function(a){return a["protected"]?1:a["private"]?2:0}})(g.MemberBuilderValidator={},".");(function(c){var a=c.exports={};j=".";var b=f("./util");c.exports=a=function(){if(!(this instanceof a))return new c.exports};a.prototype.setup=function(a,b,c){var h=this._createPrivateLayer(a,b);this._doSetup(a,b["public"]);this._doSetup(a,b["protected"],c["protected"],!0);this._doSetup(h,b["private"],c["private"]);return h};
a.prototype._createPrivateLayer=function(a,b){var c=function(){};c.prototype=a;c=new c;this.createPropProxy(a,c,b["protected"]);return c};a.prototype._doSetup=function(a,e,c,h){var k=Array.prototype.hasOwnProperty;if(void 0!==c)for(var f in c)if(k.call(c,f)){var g=a[f],j=g&&g.___$$keywords$$;if(!h||void 0===g||j["private"]||j["protected"])a[f]=c[f]}for(var l in e)k.call(e,l)&&(a[l]=b.clone(e[l][0]))};a.prototype.createPropProxy=function(a,b,c){var h=Object.prototype.hasOwnProperty,k;for(k in c)h.call(c,
k)&&function(c){b[c]=void 0;Object.defineProperty(b,c,{set:function(b){a[c]=b},get:function(){return a[c]},enumerable:!0})}.call(null,k);return b}})(g.VisibilityObjectFactory={},".");(function(c){var a=c.exports={};j=".";c.exports=a=function(){if(!(this instanceof a))return new c.exports};a.prototype=f("./VisibilityObjectFactory")();a.prototype._createPrivateLayer=function(a){return a};a.prototype.createPropProxy=function(a){return a}})(g.FallbackVisibilityObjectFactory={},".");(function(c){c=c.exports=
{};j=".";var a=f("./util"),b=f("./VisibilityObjectFactory"),d=f("./FallbackVisibilityObjectFactory");c.fromEnvironment=function(){return a.definePropertyFallback()?d():b()}})(g.VisibilityObjectFactoryFactory={},".");(function(c){function a(a){if(1<arguments.length)throw Error("Expecting one argument for anonymous Class definition; "+arguments.length+" given.");return k(a)}function b(a,b){if(2<arguments.length)throw Error("Expecting at most two arguments for definition of named Class '"+a+"'; "+arguments.length+
" given.");if(void 0===b)return d(a);if("object"!==typeof b)throw TypeError("Unexpected value for definition of named Class '"+a+"'; object expected");b.__name=a;return k(b)}function d(a){return{extend:function(){for(var b=[],d=arguments.length;d--;)b[d]=arguments[d];b[b.length-1].__name=a;return k.apply(null,b)},implement:function(){for(var b=[],d=arguments.length;d--;)b[d]=arguments[d];return e(null,b,a)},use:function(){for(var a=[],b=arguments.length;b--;)a[b]=arguments[b];return i(v,a)}}}function e(a,
b,d){var e={extend:function(){var e=arguments.length,c=arguments[e-1],i=1<e?arguments[e-2]:null;if(2<e)throw Error("Expecting no more than two arguments for extend()");if(a&&i)throw Error("Cannot override parent "+a.toString()+" with "+i.toString()+" via extend()");if(d)c.__name=d;b.push(a||i||k({}));return k.call(null,z.apply(this,b),c)},use:function(){for(var a=[],b=arguments.length;b--;)a[b]=arguments[b];return i(function(){return e.__createBase()},a)},__createBase:function(){return e.extend({})}};
return e}function i(a,b,d){var e=function(){if(!d)throw TypeError("Cannot instantiate incomplete class definition; did you forget to call `extend'?");return h(a(),b).apply(null,arguments)};e.extend=function(){var d=arguments.length,e=arguments[d-1],d=1<d?arguments[d-2]:null,c=a();return k.call(null,h(c||d,b),e)};e.use=function(){for(var a=[],b=arguments.length;b--;)a[b]=arguments[b];return i(function(){return e.__createBase()},a,d)};e.__createBase=function(){return e.extend({})};return e}function h(a,
b){for(var d={___$$auto$abstract$$:!0},e=[],c=0,i=b.length;c<i;c++)b[c].__mixin(d,e,a||q.ClassBase);d=k.call(null,a,d);e=q.getMeta(d).implemented;c=0;for(i=b.length;c<i;c++)e.push(b[c]),b[c].__mixinImpl(e);return d}function k(a,b){for(var d=[],e=arguments.length;e--;)d[e]=arguments[e];d=u.build.apply(u,d);g(d);r(d);t(d);p.freeze(d);return d}function g(a){p.defineSecureProp(a,"extend",function(a){return k(this,a)})}function r(a){p.defineSecureProp(a,"implement",function(){for(var b=[],d=arguments.length;d--;)b[d]=
arguments[d];return e(a,b)})}function t(a){p.defineSecureProp(a,"use",function(){for(var b=[],d=arguments.length;d--;)b[d]=arguments[d];return i(function(){return a},b,!0)})}c.exports={};j=".";var l="undefined"!==typeof console?console:void 0,p=f("./util"),q=f("./ClassBuilder"),s=f("./warn"),n=s.Warning,m=s.LogHandler(l),l=f("./MethodWrapperFactory"),s=f("./MethodWrappers").standard,u=q(m,f("./MemberBuilder")(l(s.wrapNew),l(s.wrapOverride),l(s.wrapProxy),f("./MemberBuilderValidator")(function(a){m.handle(n(a))})),
f("./VisibilityObjectFactoryFactory").fromEnvironment()),v=function(){return null};c.exports=function(d,e){for(var c=typeof d,i=null,i=[],h=arguments.length;h--;)i[h]=arguments[h];switch(c){case "object":i=a.apply(null,i);break;case "string":i=b.apply(null,i);break;default:throw TypeError("Expecting anonymous class definition or named class definition");}return i};c.exports.extend=k;c.exports.implement=function(a){return e(null,Array.prototype.slice.call(arguments))};c.exports.use=function(a){for(var b=
[],d=arguments.length;d--;)b[d]=arguments[d];return i(v,b)};var o={prototype:{}},y={constructor:{prototype:{}}};c.exports.isClass=function(a){a=a||o;if(!a.prototype)return!1;var b=q.getMeta(a);return null!==b&&b.implemented||a.prototype instanceof q.ClassBase?!0:!1};c.exports.isClassInstance=function(a){a=a||y;return c.exports.isClass(a.constructor)};c.exports.isInstanceOf=q.isInstanceOf;c.exports.isA=c.exports.isInstanceOf;var z=function(a,b){for(var d=arguments.length,e={},i=arguments[d-1],h=null,
k=[],f=!1,g=0;g<d-1;g++)h=arguments[g],p.propParse(h.prototype,{method:function(a,b){e["abstract "+a]=b.definition;f=!0}}),k.push(h);if(f)e.___$$abstract$$=!0;d=c.exports.extend(i,e);q.getMeta(d).implemented=k;return d}})(g["class"]={},".");(function(c){function a(a){if("object"===typeof a)a.___$$abstract$$=!0}function b(d){var e=d.extend,c=d.implement,f=d.use;c&&(d.implement=function(){return b(c.apply(this,arguments))});f&&(d.use=function(){return b(f.apply(this,arguments))});d.extend=function(){a(arguments[arguments.length-
1]);return e.apply(this,arguments)};d.__createBase=function(){return e({___$$auto$abstract$$:!0})};return d}var d=c.exports={};j=".";var e=f("./class");c.exports=d=function(){a(arguments[arguments.length-1]);var d=e.apply(this,arguments);e.isClass(d)||b(d);return d};d.extend=function(){a(arguments[arguments.length-1]);return e.extend.apply(this,arguments)};d.use=function(){return b(e.use.apply(this,arguments))};d.implement=function(){return b(e.implement.apply(this,arguments))}})(g.class_abstract=
{},".");(function(c){function a(){}function b(a){if(1<arguments.length)throw Error("Expecting one argument for Interface definition; "+arguments.length+" given.");return m(a)}function d(a,b){if(2<arguments.length)throw Error("Expecting two arguments for definition of named Interface '"+a+"'; "+arguments.length+" given.");if("object"!==typeof b)throw TypeError("Unexpected value for definition of named Interface '"+a+"'; object expected");b.__name=a;return m(b)}function e(a,b){b.message="Failed to define interface "+
(a?a:"(anonymous)")+": "+b.message;throw b;}function i(a){l.defineSecureProp(a,"extend",function(a){return m(this,a)})}function h(a,b){a.toString=b?function(){return"[object Interface <"+b+">]"}:function(){return"[object Interface]"}}function k(a){l.defineSecureProp(a,"isCompatible",function(b){return 0===g(a,b).length})}function g(a,b){var d=[];l.propParse(a.prototype,{method:function(a,e){"function"!==typeof b[a]?d.push([a,"missing"]):b[a].length<e.__length&&d.push([a,"incompatible"])}});return d}
function r(a){l.defineSecureProp(a,"__isInstanceOf",function(a,b){return t(a,b)})}function t(a,b){var d=b.constructor,e;if(!b.__cid||!(e=n.getMeta(d)))return 0===g(a,b).length;d=e.implemented;for(e=d.length;e--;)if(d[e]===a)return!0;return!1}c.exports={};j=".";var l=f("./util"),p=f("./MethodWrapperFactory"),q=f("./MethodWrappers").standard,s=f("./MemberBuilder")(p(q.wrapNew),p(q.wrapOverride),p(q.wrapProxy),f("./MemberBuilderValidator")());f("./class");var n=f("./ClassBuilder");c.exports=function(a,
e){var c=null;switch(typeof a){case "object":c=b.apply(null,arguments);break;case "string":c=d.apply(null,arguments);break;default:throw TypeError("Expecting anonymous interface definition or named interface definition");}return c};c.exports.extend=function(){return m.apply(this,arguments)};c.exports.isInterface=function(b){b=b||{};return b.prototype instanceof a?!0:!1};var m=function(b){function d(a){return function(){if(!b)throw Error("Interface "+(a?a+" ":"")+" cannot be instantiated");}}return function(){b=
!0;var c=arguments,f=c.length,g=(0<f?c[f-1]:0)||{},c=new ((1<f?c[f-2]:0)||a),j="",x={},F=s.initMembers(c,c,c);(j=g.__name)&&delete g.__name;if(!(c instanceof a))throw new TypeError("Interfaces may only extend other interfaces");f=d(j);l.propParse(g,{assumeAbstract:!0,_throw:function(a){e(j,a)},property:function(){e(j,TypeError("Unexpected internal error"))},getset:function(){e(j,TypeError("Unexpected internal error"))},method:function(a,b,d,c){(c["protected"]||c["private"])&&e(j,TypeError("Member "+
a+" must be public"));s.buildMethod(F,null,a,b,c,null,0,{},x)}});i(f);h(f,j);k(f);r(f);f.prototype=c;f.constructor=f;l.freeze(f);b=!1;return f}}(!1);c.exports.isInstanceOf=t})(g["interface"]={},".");(function(c){function a(){}function b(){switch(arguments.length){case 0:throw Error("Missing trait name or definition");case 1:return"string"===typeof arguments[0]?e.apply(this,arguments):b.extend.apply(this,arguments);case 2:return d.apply(this,arguments)}throw Error("Expecting at most two arguments for definition of named Trait "+
name+"'; "+arguments.length+" given");}function d(a,d){if("string"!==typeof a)throw Error("First argument of named class definition must be a string");d.__name=a;return b.extend(d)}function e(a){return{extend:function(b){return d(a,b)},implement:function(){return g(arguments,a)}}}function i(a,b,d,e){if("__construct"===a)throw Error("Traits may not define __construct");if(d["static"])throw Error("Cannot define member `"+a+"'; static trait members are currently unsupported");e.apply(this,arguments)}
function h(a,b,d,e){if("___"!==a.substr(0,3)){if(!d["private"])throw Error("Cannot define property `"+a+"'; only private properties are permitted within Trait definitions");e.apply(this,arguments)}}function k(a){throw Error("Cannot define property `"+a+"'; getters/setters are currently unsupported");}function g(a,d){return{extend:function(e){if(d)e.__name=d;return b.extend.call({__$$meta:{ifaces:a}},e)}}}function r(a){var b={"protected ___$$pmo$$":null,"protected ___$$super$$":null,__construct:function(a,
b){this.___$$super$$=a;this.___$$pmo$$=b},__name:"#ConcreteTrait#"},d=v.getMeta(a).abstractMethods,e;for(e in d)Object.hasOwnProperty.call(d,e)&&"__"!==e.substr(0,2)&&(b[(void 0!==a.___$$methods$$["public"][e]?"public":"protected")+" proxy "+e]="___$$pmo$$");t(a,b);return a.extend(b)}function t(a,b){var d=v.getMeta(a).virtualMembers,e;for(e in d){var c=void 0!==a.___$$methods$$["public"][e]?"public":"protected",i=a.___$$methods$$[c][e],h=i.__length;b[c+" virtual override "+e]=function(a){var b=function(){var b=
this.___$$pmo$$,d=b[a];return d?d.apply(b,arguments):this.__super.apply(this,arguments)};b.__length=h;return b}(e);b[c+" virtual __$$"+e]=function(a){var b=function(){return a.apply(this,arguments)};b.__length=h;return b}(i)}}function l(b,d,e,c){var i=b.__acls,b=s(b,d,e,c);d["weak virtual ___$$ctor$pre$$"]=a;d["weak virtual ___$$ctor$post$$"]=a;c===v.ClassBase?(d["virtual override ___$$ctor$post$$"]=m,d["virtual override ___$$ctor$pre$$"]=a):(d["virtual override ___$$ctor$post$$"]=a,d["virtual override ___$$ctor$pre$$"]=
m);p(i,d,b);return d}function p(a,b,d){a=a.___$$methods$$;q(a["public"],b,"public",d);q(a["protected"],b,"protected",d);(a=a["public"].___$$parent$$)&&a.constructor!==v.ClassBase&&p(a.constructor,b,d)}function q(a,b,d,e){for(var c in a)if(Object.hasOwnProperty.call(a,c)&&"__mixin"!==c&&a[c].___$$keywords$$){var i=a[c].___$$keywords$$,d=i["protected"]?"protected":"public";if(i["abstract"]&&!i.override)b[d+" weak abstract "+c]=a[c].definition;else{var h=i.virtual,d=(h?"":"proxy ")+(h?"virtual ":"")+
(i.override?"override ":"")+d+" "+c;if(void 0!==b[d])throw Error("Trait member conflict: `"+c+"'");b[d]=i.virtual?function(b){var d=function(){var a=this[e],d=a["__$$"+b].apply(a,arguments);return d===a?this:d};d.__length=a[b].__length;return d}(c):e}}}function s(a,b,d,e){var c="___$to$"+a.__acls.__cid+"$"+e.__cid;d.push([c,a]);b["private "+c]=null;void 0===b.___$$tctor$$&&(b["weak virtual ___$$tctor$$"]=function(){},b["virtual override ___$$tctor$$"]=n(d,e));return c}function n(a,b){return function(d){for(var e in a){var c=
a[e][0],i=a[e][1],h=i.__ccls||(i.__ccls=r(i.__acls));this[c]=h(b,this[d].vis)[d].vis;this[c].__mixin&&this[c].__mixin.apply(this[c],i.___$$mixinargs)}this.__super&&this.__super(d)}}function m(){this.___$$tctor$$.apply(this,arguments)}c.exports={};j=".";var u=f("./class_abstract"),v=f("./ClassBuilder"),o=f("./interface");b.extend=function(a){var b=(this||{}).__$$meta||{},d=a.__name||"(Trait)",e="function"===typeof a.__mixin?"param":"std";a.___$$parser$$={each:i,property:h,getset:k};a.___$$auto$abstract$$=
!0;a.__name="#AbstractTrait#";var c="param"===e?function(){for(var a=[],b=arguments.length;b--;)a[b]=arguments[b];var d=function(){throw Error("Cannot re-configure argument trait");};d.___$$mixinargs=a;d.__trait="arg";d.__acls=c.__acls;d.__ccls=c.__ccls;d.toString=c.toString;d.__mixinImpl=c.__mixinImpl;d.__isInstanceOf=c.__isInstanceOf;d.__mixin=function(a,b,e){l(d,a,b,e)};return d}:function(){throw Error("Cannot instantiate non-parameterized trait");},f=u;b.ifaces&&(f=f.implement.apply(null,b.ifaces));
var g=f.extend(a);c.__trait=e;c.__acls=g;c.__ccls=null;c.toString=function(){return""+d};c.___$$mixinargs=[];c.__mixin=function(a,b,d){l(c,a,b,d)};c.__mixinImpl=function(a){for(var b=v.getMeta(g).implemented||[],d=b.length;d--;)a.push(b[d])};c.__isInstanceOf=o.isInstanceOf;return c};b.implement=function(){return g(arguments)};b.isTrait=function(a){return!!(a||{}).__trait};b.isParameterTrait=function(a){return"param"===(a||{}).__trait};b.isArgumentTrait=function(a){return"arg"===(a||{}).__trait};c.exports=
b})(g.Trait={},".");(function(c){function a(a){if("object"===typeof a)a.___$$final$$=!0}function b(b){var d=b.extend;b.extend=function(){a(arguments[arguments.length-1]);return d.apply(this,arguments)}}var d=c.exports={};j=".";var e=f("./class"),d=c.exports=function(){a(arguments[arguments.length-1]);var d=e.apply(this,arguments);e.isClass(d)||b(d);return d};d.extend=function(){a(arguments[arguments.length-1]);return e.extend.apply(this,arguments)}})(g.class_final={},".");(function(c){var a=c.exports=
{};j=".";var b=f("./MemberBuilder");c.exports=a=function(a,b){if(!(this instanceof c.exports))return new c.exports(a,b);c.exports.prototype.constructor.call(this,a,b)};c.exports.prototype=new b;c.exports.constructor=c.exports;a.prototype.buildGetterSetter=function(){throw Error("Getters/setters are unsupported in this environment");}})(g.FallbackMemberBuilder={},".");(function(c){function a(){if(!(this instanceof a))return new a;this._alt={}}c.exports={};j="util";(0,eval)("var _the_global=this");
a.expose=function(){return _the_global};a.prototype={provideAlt:function(a,d){if(!(void 0!==_the_global[a]||void 0!==this._alt[a]))return this._alt[a]=d(),this},get:function(a){return void 0!==this._alt[a]?this._alt[a]:_the_global[a]}};c.exports=a})(g["util/Global"]={},".");(function(c){c.exports={};j="util";var a=f("./symbol/FallbackSymbol"),b=f("./Global").expose();c.exports=b.Symbol||a})(g["util/Symbol"]={},".");(function(c){function a(){if(!(this instanceof a))return new a;this.___$$id$$=e+d(1E8*
b())}c.exports={};j="util/symbol";var b=Math.random,d=Math.floor,e=" "+String.fromCharCode(d(10*b())%31+1)+"$";a.prototype={toString:function(){return this.___$$id$$}};c.exports=a})(g["util/symbol/FallbackSymbol"]={},".");(function(c){c.exports={};j=".";var a=[0,2,4,""];a.major=0;a.minor=2;a.rev=4;a.suffix="";a.toString=function(){return this.join(".").replace(/\.([^.]*)$/,"-$1").replace(/-$/,"")};c.exports=a})(g.version={},".");(function(c){function a(){if(!(this instanceof a))return new a}c.exports=
{};j="warn";a.prototype={handle:function(){}};c.exports=a})(g["warn/DismissiveHandler"]={},".");(function(c){function a(b){if(!(this instanceof a))return new a(b);this._console=b||{}}c.exports={};j="warn";a.prototype={handle:function(a){var d=this._console.warn||this._console.log;d&&d.call(this._console,"Warning: "+a.message)}};c.exports=a})(g["warn/LogHandler"]={},".");(function(c){function a(){if(!(this instanceof a))return new a}c.exports={};j="warn";a.prototype={handle:function(a){throw a.getError();
}};c.exports=a})(g["warn/ThrowHandler"]={},".");(function(c){function a(b){if(!(this instanceof a))return new a(b);if(!(b instanceof Error))throw TypeError("Must provide exception to wrap");Error.prototype.constructor.call(this,b.message);this.message=b.message;this.name="Warning";this._error=b;this.stack=b.stack&&b.stack.replace(/^.*?\n+/,this.name+": "+this.message+"\n")}c.exports={};j="warn";a.prototype=Error();a.prototype.constructor=a;a.prototype.name="Warning";a.prototype.getError=function(){return this._error};
c.exports=a})(g["warn/Warning"]={},".");g.common=g["test/common"]={exports:{require:function(c){return f(c)},testCase:function(){return f("/test/inc-testcase").apply(this,arguments)}}};g.assert={exports:{equal:function(c,a,b){c!=a&&A(b)},strictEqual:function(c,a,b){c!==a&&A(b)},notStrictEqual:function(c,a,b){c===a&&A(b)},notEqual:function(c,a,b){c===a&&A(b)},deepEqual:function(c,a,b){if(c!=a)if(a instanceof Array&&c instanceof Array)for(var d=0,e=a.length;d<e;d++)g.assert.exports.deepEqual(c[d],a[d],
b);else if("object"===typeof a&&"object"===typeof c)for(d in a)g.assert.exports.deepEqual(c[d],a[d],b);else A(b)},ok:function(c,a){c||A(a)},fail:function(c){A(c)},"throws":function(c,a,b){a=a||Error;try{c()}catch(d){d instanceof a||A(b)}},doesNotThrow:function(c,a,b){a=a||Error;try{c()}catch(d){d instanceof a&&A(b)}}}};D.runTests=function(){(function(c,a){function b(){g++}function d(){o("\n");0!==p%60&&o("\n");if(s.length){var a=s,b,d,e;if("undefined"===typeof process){e="";b=a.length;for(b in a)d=
a[b],e+=d[0]+" ("+(d[1].message||"no message")+")"+(d[1].stack?"<br />"+d[1].stack.replace(/\n/g,"<br />")+"<br />":"; ");throw Error(e);}for(b=0;b<a.length;b++)d=a[b],e=d[0],d=d[1],o("#"+b+" "+e+"\n"+(d.stack||d)+"\n\n")}o((s.length?"FAILED":"OK")+" - "+t+" successful, "+s.length+" failure(s), "+(0<r?r+" incomplete, ":"")+(0<l?l+" skipped, ":"")+(t+r+l+s.length)+" total ("+g+" assertion"+(1!==g?"s":"")+")\n");s.length&&"undefined"!==typeof process&&process.exit(1)}function e(a){var a=m(a),b=function(){},
a=b.prototype=new a,d;for(d in a)"function"===typeof a[d]&&(a[d]=function(){});return new b}function i(){throw n;}c.exports={};j=".";document.write("test/inc-testcase...<br />");var h=f("assert"),k={},g=0,r=0,t=0,l=0,p=0,q=!1,s=[],n={skip:!0},m=f(a+"/common").require,u;for(u in h){var v=h[u];"function"===typeof v&&(k[u]=function(a){return function(){g++;a.apply(this,arguments)}}(v))}c.exports=function(a,c){var h=Array.prototype.slice.call(arguments),f=h.pop(),h=h.pop(),j={require:m,fail:k.fail,assertOk:k.ok,
assertEqual:k.equal,assertNotEqual:k.notEqual,assertDeepEqual:k.deepEqual,assertStrictEqual:k.strictEqual,assertNotStrictEqual:k.notStrictEqual,assertThrows:k["throws"],assertDoesNotThrow:k.doesNotThrow,assertIfError:k.ifError,incAssertCount:b,getMock:e,skip:i},u=f.setUp;if(h)j.Sut=m(h);q||(s=[],t=g=r=l=0);f.caseSetUp&&f.caseSetUp.call(j);delete f.caseSetUp;delete f.setUp;for(var v in f){var h=v.match(/^(?:@(.*?)\((.*?)\))?(.*)$/),B=h[1],A=h[2],D=h[3],G=1,h=[[]];if("each"===B){if(!j[A])throw Error("Unknown @each context: "+
A);G=j[A].length;h=[];for(B=0;B<G;B++)h.push([j[A][B]])}else if(B)throw Error("Unknown test method: "+B);for(B=0;B<G;B++){var A=f,K=v,H=u||null,L=D+(1<G?" ("+B+")":""),I=j,M=h[B],N=g;try{H&&H.call(I),A[K].apply(I,M),N===g?(o("I"),r++):(t++,o("."))}catch(J){J===n?(o("S"),l++):(o("F"),s.push([L,J]))}p++;p%60||o(" "+p+"\n")}}q||d()};c.exports.startSuite=function(){s=[];t=g=r=l=0;q=!0};c.exports.endSuite=function(){q=!1;d()};var o="undefined"===typeof process||"undefined"===typeof process.stdout?function(){}:
function(a){process.stdout.write(a)}})(g["test/inc-testcase"]={},"test");(function(c){c=c.exports={};j=".";document.write("test/MemberBuilder/inc-common...<br />");c.testArgs=function(a,b,d,e,c,h,f){var g={value:{expected:null,given:b[3]},keywords:{expected:null,given:b[4]}},g=f(g,g.value.given,g.keywords.given);a.assertEqual(d,b[0],"Incorrect name passed to validator");a.assertDeepEqual(e,b[1],"Incorrect value passed to validator");a.assertStrictEqual(c,b[2],"Incorrect keywords passed to validator");
a.assertStrictEqual(g.value.expected,g.value.given,"Previous data should contain prev value if overriding, otherwise null");a.assertDeepEqual(g.keywords.expected,g.keywords.given,"Previous keywords should contain prev keyword if overriding, otherwise null");a.assertStrictEqual(h,b[5],"State object was not passed to validator")}})(g["test/MemberBuilder/inc-common"]={},"test/MemberBuilder");(function(c){var a=c.exports={};j=".";document.write("test/MemberBuilderValidator/inc-common...<br />");a.testName=
"fooBar";a.quickFailureTest=function(a,d,e){this.incAssertCount();try{e()}catch(c){this.assertOk(-1!==c.message.search(d),"Incorrect error; expected identifier '"+d+"', but received: "+c.message);this.assertOk(-1!==c.message.search(a),"Error message should contain member name");return}this.fail(!1,!0,"Expected failure")};a.quickKeywordTest=function(b,d,e,c,h){for(var f={},g={},h=h||{},j=a.testName,t={},l=this,p=0,q=d.length;p<q;p++)f[d[p]]=!0;if(void 0!==c){p=0;for(q=c.length;p<q;p++)g[c[p]]=!0;h.member=
function(){}}d=function(){l.sut[b](j,f.proxy?"proxyDest":function(){},f,h,g,t)};e?this.quickFailureTest.call(this,j,e,d):this.assertDoesNotThrow(d);this.sut.end(t)};a.visEscalationTest=function(a){for(var d=[["protected","public"],["public","public"],["protected","protected"]],e=0,c=d.length;e<c;e++)a(d[e])};a.privateNamingConflictTest=function(a){for(var d=[["private","private"],["private","protected"],["private"," public"]],e=d.length;e--;)a(d[e])};a.quickVisChangeTest=function(a,d,e,c,h){var f=
{},g={};f[a]=!0;g[d]=!0;a=function(){c("foo",f,g)};e?this.quickFailureTest.call(this,"foo",h||"de-escalate",a):this.assertDoesNotThrow(a,Error)}})(g["test/MemberBuilderValidator/inc-common"]={},"test/MemberBuilderValidator");(function(c){c.exports={};j=".";document.write("test/Class/AbstractTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=this.require("class_abstract");this.Class=this.require("class")},"Must declare classes with abstract members as abstract":function(){try{this.Class("Foo",
{"abstract foo":[]})}catch(a){this.assertOk(-1!==a.message.search("Foo"),"Abstract class declaration error should contain class name");return}this.assertFail("Should not be able to declare abstract members unless class is also declared as abstract")},"Can declare class as abstract":function(){var a=this.Sut;this.assertDoesNotThrow(function(){a({"abstract foo":[]})},Error)},"Abstract classes must contain abstract methods":function(){try{this.Sut("Foo",{})}catch(a){this.assertOk(-1!==a.message.search("Foo"),
"Abstract class declaration error should contain class name");return}this.assertFail("Abstract classes should contain at least one abstract method")},"Abstract methods can be defined concretely by sub-subtypes":function(){var a=this.Sut.extend(this.Sut("Foo",{"abstract foo":[]}),{}),b=this.Class;this.assertDoesNotThrow(function(){b.extend(a,{foo:function(){}})},Error)},"Abstract class extend method returns new class":function(){this.assertEqual(typeof this.Sut.extend,"function","AbstractClass contains extend method");
this.assertOk(this.Class.isClass(this.Sut.extend({"abstract foo":[]})),"Abstract class extend method returns class")},"Abstract class contains implement method":function(){this.assertEqual(typeof this.Sut.implement,"function","AbstractClass contains implement method")},"All classes have an isAbstract() method":function(){this.assertEqual(typeof this.Class({}).isAbstract,"function")},"Concrete classes are not considered to be abstract":function(){this.assertOk(!this.Class({}).isAbstract())},"Abstract classes are considered to be abstract":function(){this.assertOk(this.Sut({"abstract method":[]}).isAbstract())},
"Subtypes are abstract if no concrete method is provided":function(){this.assertOk(this.Sut.extend(this.Sut({"abstract foo":[],"abstract bar":[]}),{foo:function(){}}).isAbstract())},"Subtypes are not considered abstract if concrete methods are provided":function(){this.assertOk(!1===this.Class.extend(this.Sut({"abstract foo":[],"abstract bar":[]}),{foo:function(){},bar:function(){}}).isAbstract())},"Abstract classes cannot be instantiated":function(){var a=this.Sut;this.assertThrows(function(){a({"abstract foo":[]})()},
Error)},"Concrete subtypes of abstract classes can be instantiated":function(){var a=this.Sut;this.assertDoesNotThrow(function(){a({"abstract foo":[]}).extend({foo:function(){}})()},Error)},"Can call constructors of abstract supertypes":function(){var a=!1;this.Sut({__construct:function(){a=!0},"abstract foo":[]}).extend({foo:function(){}})();this.assertOk(a)},"Concrete methods must implement the proper number of parameters":function(){var a=this.Sut;this.assertThrows(function(){a({"abstract foo":["one",
"two"]}).extend({foo:function(){}})},Error)},"Abstract methods of subtypes must declare compatible parameter count":function(){var a=this.Sut;this.assertThrows(function(){a.extend(a({"abstract foo":["one"]}),{"abstract foo":[]})},TypeError)},"Abstract members may implement more parameters than supertype":function(){var a=this.Sut;this.assertDoesNotThrow(function(){a.extend(a({"abstract foo":["one"]}),{"abstract foo":["one","two"]})},Error)},"Abstract members may implement equal parameters to supertype":function(){var a=
this.Sut;this.assertDoesNotThrow(function(){a.extend(a({"abstract foo":["one"]}),{"abstract foo":["one"]})},Error)},"Concrete methods have no parameter requirement with empty definition":function(){var a=this.Sut;this.assertDoesNotThrow(function(){a({"abstract foo":[]}).extend({foo:function(){}})},Error)},"Abstract methods must be declared as arrays":function(){var a=this.Class;this.assertThrows(function(){a.extend({"abstract foo":function(){}})},TypeError,"Abstract method cannot be declared as a function");
this.assertThrows(function(){a.extend({"abstract foo":"scalar"})},TypeError,"Abstract method cannot be declared as a scalar")},"Does not recognize object prototype members as abstract":function(){var a=this.Sut;this.assertDoesNotThrow(function(){a({"abstract method":[]}).extend({method:function(){},toString:function(){}})()},Error)},"Can create named abstract subtypes":function(){this.assertOk(this.Sut("Named").extend(this.Sut({"abstract foo":[]}),{}).isAbstract())},"Calling extend() on abstract class yields concrete class":function(){var a=
this.Sut({"abstract foo":[]}),b=this.Sut("NamedSubFoo").extend(a,{}),d=this.Sut.extend(a,{}),e=this.Class;this.assertThrows(function(){e.isAbstract(b.extend({}))},TypeError,"Extending named abstract classes should be concrete");this.assertThrows(function(){e.isAbstract(d.extend({}))},TypeError,"Extending anonymous abstract classes should be concrete")},"Implementing interfaces will preserve abstract class definition":function(){var a=this.Sut,b=this.require("interface");this.assertOk(a("TestImplExtend").implement(b({foo:[]})).extend({}).isAbstract())}})})(g["test/Class/AbstractTest"]=
{},"test/Class");(function(c){c.exports={};j=".";document.write("test/ClassBuilder/ConstTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=this.require("ClassBuilder");this.MethodWrapperFactory=this.require("MethodWrapperFactory");this.wrappers=this.require("MethodWrappers").standard},setUp:function(){this.builder=this.Sut(this.require("warn").DismissiveHandler(),this.require("MemberBuilder")(this.MethodWrapperFactory(this.wrappers.wrapNew),this.MethodWrapperFactory(this.wrappers.wrapOverride),
this.MethodWrapperFactory(this.wrappers.wrapProxy),this.getMock("MemberBuilderValidator")),this.require("VisibilityObjectFactoryFactory").fromEnvironment())},"const keyword declares properties as static":function(){this.assertEqual("baz",this.builder.build({"const foo":"baz"}).$("foo"),"Const keyword should declare properties as static")},"const keyword creates immutable property":function(){try{this.builder.build({"const foo":"bar"}).$("foo","baz")}catch(a){this.assertOk(-1!==a.message.search("foo"),
"Const modification error should contain name of property");return}this.fail("Constant properties should not be writable")},"Access modifiers are permitted with const keyword":function(){var a=this.builder.build({"protected const prot":"bar","private   const priv":"baz","public static getProt":function(){return this.$("prot")},"public static getPriv":function(){return this.$("priv")}}),b=this.builder.build(a,{"public static getProt":function(){return this.$("prot")},"public static getPriv":function(){return this.$("priv")}});
this.assertEqual(a.$("prot"),void 0,"Protected constants are not available publicly");this.assertEqual(a.$("priv"),void 0,"Private constants are not available publicly");this.assertEqual(a.getProt(),"bar","Protected constants are available internally");this.assertEqual(a.getPriv(),"baz","Private constants are available internally");this.assertEqual(b.getProt(),"bar","Protected constants are available to subtypes internally");this.assertEqual(b.getPriv(),void 0,"Private constants are NOT available to subtypes internally")}})})(g["test/ClassBuilder/ConstTest"]=
{},"test/ClassBuilder");(function(c){c.exports={};j=".";document.write("test/ClassBuilder/FinalTest...<br />");f("common").testCase({caseSetUp:function(){this.Class=this.require("class");this.FinalClass=this.require("class_final")},"Final classes are valid classes":function(){this.assertOk(this.Class.isClass(this.FinalClass({})),"Final classes should generate valid classes")},"Final classes cannot be extended":function(){try{this.FinalClass("Foo",{}).extend({})}catch(a){this.assertOk(-1!==a.message.search("Foo"),
"Final class error message should contain name of class");return}this.assertFail("Should not be able to extend final classes")},"Can create final subtypes":function(){var a=this.require("ClassBuilder")(this.require("warn").DismissiveHandler(),this.require("MemberBuilder")(),this.require("VisibilityObjectFactoryFactory").fromEnvironment()).build({}),b=this.FinalClass("FinalNamed").extend(a,{}),d=this.FinalClass.extend(a,{});this.assertThrows(function(){b.extend({})},Error,"Cannot extend final named subtype");
this.assertThrows(function(){d.extend({})},Error,"Cannot extend final anonymous subtype")}})})(g["test/ClassBuilder/FinalTest"]={},"test/ClassBuilder");(function(c){c.exports={};j=".";document.write("test/ClassBuilder/InstanceTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=this.require("ClassBuilder")},"Delegates to type-specific instance method if present":function(){var a=this,b={},d=!1,e={__isInstanceOf:function(c,h){a.assertStrictEqual(c,e);a.assertStrictEqual(h,b);return d=
!0}};this.assertOk(this.Sut.isInstanceOf(e,b));this.assertOk(d)},"Falls back to ECMAScript instanceof check lacking type method":function(){var a=function(){},b=new a;this.assertOk(this.Sut.isInstanceOf(a,b));this.assertOk(!this.Sut.isInstanceOf(a,{}))},"Fallback does not throw exception if type is not a constructor":function(){var a=this;this.assertDoesNotThrow(function(){a.assertOk(!a.Sut.isInstanceOf({},{}))})}})})(g["test/ClassBuilder/InstanceTest"]={},"test/ClassBuilder");(function(c){c.exports=
{};j=".";document.write("test/ClassBuilder/MemberRestrictionTest...<br />");f("common").testCase({caseSetUp:function(){this.Class=this.require("class");this.AbstractClass=this.require("class_abstract");this.Sut=this.require("ClassBuilder");this.weak=[["weak foo","foo"],["foo","weak foo"],["weak foo","weak foo"]]},"Can retrieve a list of reserved members":function(){this.assertOk(this.Sut.getReservedMembers()instanceof Object,"Can retrieve hash of reserved members")},"Cannot modify internal reserved members list":function(){this.Sut.getReservedMembers().foo=
"foo";this.assertNotEqual(this.Sut.getReservedMembers().foo,"foo","Cannot alter internal list of reserved members")},"Proper members are reserved":function(){for(var a=["__initProps","constructor"],b=a.length,d=this.Sut.getReservedMembers();b--;){var e=a[b];this.assertOk(d.hasOwnProperty(e),"Member '"+e+"' should be reserved");delete d[e]}for(var c in d)this.assertFail("Untested reserved member found: "+c)},"All reserved members are actually reserved":function(){var a=this,b=this.Sut.getReservedMembers(),
d=0,e;for(e in b)this.assertThrows(function(){var b={};b[e]="";a.Class(b)},Error,"Reserved members cannot be used in class definitions as properties"),this.assertThrows(function(){var b={};b[e]=function(){};a.Class(b)},Error,"Reserved members cannot be used in class definitions as methods"),d++;this.assertNotEqual(d,0,"Reserved memebers were tested")},"Can retrieve list of forced public methods":function(){var a=this.Sut.getForcedPublicMethods(),b=0;this.assertOk(a instanceof Object,"Can retrieve hash of forced-public methods");
for(var d in a)b++;this.assertNotEqual(b,0,"Forced-public method list is not empty")},"Cannot modify internal forced public methods list":function(){this.Sut.getForcedPublicMethods().foo="foo";this.assertNotEqual(this.Sut.getForcedPublicMethods().foo,"foo","Cannot alter internal list of forced-public methods")},"All forced public methods are forced to public":function(){var a=this,b=this.Sut.getForcedPublicMethods(),d;for(d in b)this.assertThrows(function(){var b={};b["private "+d]=function(){};a.Class(b)},
Error,"Forced-public methods must be declared as public")},"Cannot define two members of the same name":function(){var a=this;this.assertThrows(function(){a.Class({"public foo":function(){},"protected foo":function(){}})})},"@each(weak) Can define members of the same name if one is weak":function(a){var b={};b["abstract "+a[0]]=[];b["abstract "+a[1]]=[];var d=this;this.assertDoesNotThrow(function(){d.AbstractClass(b)})},"Member builder state is ended after processing":function(){var a=this.require("MemberBuilder")(),
b=this.Sut(this.require("warn").DismissiveHandler(),a,this.require("VisibilityObjectFactoryFactory").fromEnvironment()),d=!1;a.end=function(){d=!0};b.build({});this.assertOk(d)}})})(g["test/ClassBuilder/MemberRestrictionTest"]={},"test/ClassBuilder");(function(c){c.exports={};j=".";document.write("test/ClassBuilder/StaticTest...<br />");f("common").testCase({caseSetUp:function(){this.fallback=this.require("util").definePropertyFallback();this.ClassBuilder=this.require("ClassBuilder");this.MemberBuilder=
this.require("MemberBuilder");this.MethodWrapperFactory=this.require("MethodWrapperFactory");this.wrappers=this.require("MethodWrappers").standard},setUp:function(){this.builder=this.ClassBuilder(this.require("warn").DismissiveHandler(),this.MemberBuilder(this.MethodWrapperFactory(this.wrappers.wrapNew),this.MethodWrapperFactory(this.wrappers.wrapOverride),this.MethodWrapperFactory(this.wrappers.wrapProxy),this.getMock("MemberBuilderValidator")),this.require("VisibilityObjectFactoryFactory").fromEnvironment())},
"Self property references class definition":function(){var a=this.builder.build({"public test":function(){return this.__self}});a.bar=["baz"];this.assertOk(a().test().bar===a.bar,"__self property references class definition")},"Static property lookup returns undefined if not found":function(){this.assertEqual(this.builder.build({}).$("foo"),void 0,"Static property getter should return undefined if not found")},"Static property accessor is not enumerable":function(){var a=Object.getOwnPropertyDescriptor,
b=this.builder.build({});this.fallback||this.assertEqual(a(b,"$").enumerable,!1,"Static property accessor method should not be enumerable")},"Public static members are accessible via class definition only":function(){var a=this.builder.build({"public static foo":"foo","static bar":"bar","public static baz":function(){return"foo"},"static foobar":function(){return"bar"}});this.assertEqual(a.$("foo"),"foo","Public static properties should be accessible via class definition");this.assertEqual(a.$("bar"),
"bar","Static properties are public by default");this.assertEqual(a.baz(),"foo","Public static methods should be accessible via class definition");this.assertEqual(a.foobar(),"bar","Static methods are public by default");this.assertEqual(a.prototype.$,void 0,"Public static properties are *not* part of the prototype")},"Public static getters/setter accessible via class dfn only":function(){if(!this.fallback){var a={},b=[];Object.defineProperty(a,"public static foo",{get:function(){return"baz"},set:function(){b[0]=
!0},enumerable:!0});Object.defineProperty(a,"static bar",{get:function(){return"baz"},set:function(){b[1]=!0},enumerable:!0});a=this.builder.build(a);this.assertEqual(a.foo,"baz","Public static getters are accessible via class definition");a.foo="moo";this.assertEqual(b[0],!0,"Public static setters are accessible via class definition");this.assertEqual(a.bar,"baz","Static getters are public by default");a.bar="moo";this.assertEqual(b[1],!0,"Static setters are public by default");this.assertEqual(a.prototype.foo,
void 0,"Public static getters/getters are unavailable on prototype (0)");this.assertEqual(a.prototype.bar,void 0,"Public static getters/getters are unavailable on prototype (1)")}},"Static methods not bound to instance":function(){var a=null,b=this.builder.build({"public static foo":function(){a=this}});b.foo();this.assertEqual(a.foo,b.foo,"Static members are bound to class definition rather than instance")},"Public static members are inherited by subtypes":function(){var a={"public static foo":"val",
"public static func":function(){},"public bla":"moo"};this.fallback||Object.defineProperty(a,"public static bar",{get:function(){},set:function(){},enumerable:!0});var b=this.builder.build(a),d=this.builder.build(b,{"public static baz":"foobar"}),a=this.builder.build(d,{});this.assertEqual(d.$("foo"),b.$("foo"),"Public static properties are inherited by subtypes");this.assertEqual(a.$("foo"),b.$("foo"),"Public static properties are inherited by sub-subtypes");this.assertDeepEqual(d.func,b.func,"Public static methods are inherited by subtypes");
this.assertDeepEqual(a.func,b.func,"Public static methods are inherited by sub-subtypes");this.assertEqual(d.$("baz"),"foobar","Subtypes contain both inherited static members as well as their own");this.fallback||(b=Object.getOwnPropertyDescriptor(b,"bar"),d=Object.getOwnPropertyDescriptor(d,"bar"),a=Object.getOwnPropertyDescriptor(a,"bar"),this.assertDeepEqual(b.get,d.get,"Public static getters are inherited by subtypes"),this.assertDeepEqual(b.get,a.get,"Public static getters are inherited by sub-subtypes"),
this.assertDeepEqual(b.set,d.set,"Public static setters are inherited by subtypes"),this.assertDeepEqual(b.set,a.set,"Public static setters are inherited by sub-subtypes"))},"Public static property references are inherited by subtypes":function(){var a=[1,2,3],b=["a","b","c"],d=this.builder.build({"public static bar":a}),e=this.builder.build(d,{});this.assertOk(e.$("bar")===d.$("bar"),"Inherited static properties should share references");d.$("bar",b);this.assertDeepEqual(d.$("bar"),b,"Can set static property values");
this.assertOk(d.$("bar")===e.$("bar"),"Setting a static property value on a supertype also sets the value on subtypes");e.$("bar",a);this.assertOk(d.$("bar")===e.$("bar"))},"Setting static props to undefined will not corrupt lookup":function(){var a=this.builder.build({"public static foo":""});a.$("foo",null);this.assertStrictEqual(a.$("foo"),null,"Static properties may be set to null");a.$("foo",void 0);this.assertStrictEqual(a.$("foo"),void 0,"Static properties may be set to undefined");a.$("foo",
"baz");this.assertEqual(a.$("foo"),"baz","Setting static property to undefined does not corrupt lookup process")},"Static property setters return proper context":function(){var a=this.builder.build({"public static foo":""}),b=this.builder.build(a,{});this.assertOk(a.$("foo","val")===a,"Static property setter returns self");this.assertOk(b.$("foo","val")===b,"Static property setter returns calling class, even if property is owned by a supertype")},"Attempting to set undeclared static prop results in exception":function(){var a=
this;this.assertThrows(function(){a.builder.build({}).$("foo","val")},ReferenceError,"Attempting to set an undeclaraed static property results in an exception")},"Accessing static accessor method on non-class base also works":function(){var a=this,b=function(){},d=a.builder.build(b,{});b.$=function(){a.fail("Should not call static accessor method of non-class base")};this.assertEqual(void 0,d.$("foo"));this.assertThrows(function(){d.$("foo","val")},ReferenceError,"Attempting to set an undeclaraed static property results in an exception on non-class base")},
"Protected static members are available inside class only":function(){var a=this.builder.build({"protected static prop":"foo","protected static baz":function(){return"foo"},"public static staticBaz":function(){return this.baz()},"public instBaz":function(){return this.__self.baz()},"public static staticGetProp":function(){return this.$("prop")},"public instGetProp":function(){return this.__self.$("prop")}});this.assertEqual(a.baz,void 0,"Protected methods should not be accessible outside the class");
this.assertEqual(a.staticBaz(),"foo","Protected methods are accessible to static methods");this.assertEqual(a().instBaz(),"foo","Protected methods are accessible to instance methods");this.assertEqual(a.staticGetProp(),"foo","Protected static properties are accessible to static methods");this.assertEqual(a().instGetProp(),"foo","Protected static properties are accessible to instance methods")},"Protected static getters/setters accessible inside class only":function(){if(!this.fallback){var a={"public static getProp":function(){return this.foo},
"public static setProp":function(a){this.foo=a}},b=[];Object.defineProperty(a,"protected static foo",{get:function(){return"baz"},set:function(){b[0]=!0},enumerable:!0});a=this.builder.build(a);this.assertEqual(a.getProp(),"baz","Protected static getters are accessible from within the class");a.setProp("bla");this.assertEqual(b[0],!0,"Protected static setters are accessible from within the class");this.assertEqual(a.foo,void 0,"Protected static getters/getters are not public")}},"Protected static members are inherited by subtypes":function(){var a=
{"protected static prop":"baz","protected static foo":function(){return"baz"}};this.fallback||(Object.defineProperty(a,"protected static bar",{get:function(){},set:function(){},enumerable:!0}),a["public static getPropDesc"]=function(a){return Object.getOwnPropertyDescriptor(this,a)});var b=this.builder.build(a),d=this.builder.build(b,{"public static bar":function(){return this.foo()},"protected static foo2":function(){return"bazbaz"},"public static bar2":function(){return this.foo2()},"public static getProp":function(){return this.$("prop")}}),
a=this.builder.build(d,{});this.assertEqual(d.bar(),"baz","Subtypes inherit parents' protected static methods");this.assertEqual(d.bar2(),"bazbaz","Static methods have access to other static methods in the same class");this.assertEqual(a.bar(),"baz","Sub-subtypes inherit parents' protected static methods");this.assertEqual(d.getProp(),"baz","Subtypes inherit parents' protected static properties");this.assertEqual(a.getProp(),"baz","Sub-subtypes inherit parents' protected static properties");this.fallback||
(b=b.getPropDesc("bar"),d=d.getPropDesc("bar"),a=a.getPropDesc("bar"),this.assertDeepEqual(b.get,d.get,"Protected static getters are inherited by subtypes"),this.assertDeepEqual(b.get,a.get,"Protected static getters are inherited by sub-subtypes"),this.assertDeepEqual(b.set,d.set,"Protected static setters are inherited by subtypes"),this.assertDeepEqual(b.set,a.set,"Protected static setters are inherited by sub-subtypes"))},"Private static members are available inside class only":function(){var a=
this.builder.build({"private static prop":"foo","private static baz":function(){return"foo"},"public static staticBaz":function(){return this.baz()},"public instBaz":function(){return this.__self.baz()},"public static staticGetProp":function(){return this.$("prop")},"public instGetProp":function(){return this.__self.$("prop")}});this.assertEqual(a.baz,void 0,"Private methods should not be accessible outside the class");this.assertEqual(a.staticBaz(),"foo","Private methods are accessible to static methods");
this.assertEqual(a().instBaz(),"foo","Private methods are accessible to instance methods");this.assertEqual(a.staticGetProp(),"foo","Private static properties are accessible to static methods");this.assertEqual(a().instGetProp(),"foo","Private static properties are accessible to instance methods")},"Private static members are not inherited by subtypes":function(){var a={"private static prop":"foo","private static priv":function(){}};this.fallback||Object.defineProperty(a,"private static foo",{get:function(){return"foo"},
set:function(){},enumerable:!0});a=this.builder.build(this.builder.build(a),{"public static getPriv":function(){return this.priv},"public static getGetSet":function(){return this.foo},"public static staticGetProp":function(){return this.$("prop")},"public instGetProp":function(){return this.__self.$("prop")}});this.assertEqual(a.getPriv(),void 0,"Private static methods should not be inherited by subtypes");this.assertEqual(a.getGetSet(),void 0,"Private static getters/setters should not be inherited by subtypes");
this.assertEqual(a().instGetProp(),void 0,"Private static properties should not be inherited by subtypes (inst)");this.assertEqual(a.staticGetProp(),void 0,"Private static properties should not be inherited by subtypes (static)")},"Private static getters/setters accessible inside class only":function(){if(!this.fallback){var a={"public static getProp":function(){return this.foo},"public static setProp":function(a){this.foo=a}},b=[];Object.defineProperty(a,"private static foo",{get:function(){return"baz"},
set:function(){b[0]=!0},enumerable:!0});a=this.builder.build(a);this.assertEqual(a.getProp(),"baz","Private static getters are accessible from within the class");a.setProp("bla");this.assertEqual(b[0],!0,"Private static setters are accessible from within the class");this.assertEqual(a.foo,void 0,"Private static getters/getters are not public")}},"Static methods can be overridden by subtypes":function(){var a=this.builder.build(this.builder.build({"public static foo":function(){},"protected static bar":function(){}}),
{"public static foo":function(){return"bar"},"public static prot":function(){return this.bar()},"protected static bar":function(){return"bar"}});this.assertEqual(a.foo(),"bar","Public static methods can be overridden by subtypes");this.assertEqual(a.prot(),"bar","Protected static methods can be overridden by subtypes")},"Cannot exploit accessor method to gain access to parent private props":function(){var a=this.builder.build({"private static foo":"bar"});this.assertEqual(this.builder.build(a,{"public static getParentPrivate":function(){return this.$.call(a,
"foo")}}).getParentPrivate(),void 0,"Cannot exploit accses modifier to gain access to parent private props")},"Cannot override static members":function(){var a=this.builder.build(this.builder.build({"public static prop":"foobaz","public static foo":function(){return this.bar()},"public static bar":function(){return"foobaz"},"public static baz":function(){return this.$("prop")}}),{"public static prop":"foobar","public static bar":function(){return"foobar"},"public static getProp":function(){return this.$("prop")}});
this.assertNotEqual(a.foo(),"foobar","System does not support overriding static methods");this.assertNotEqual(a.baz(),"foobar","System does not support overriding static properties");this.assertEqual(a.bar(),"foobar","System supports static method hiding");this.assertEqual(a.getProp(),"foobar","System supports static property hiding")},"Calls to parent static methods retain private member access":function(){var a=this.builder.build(this.builder.build({"private static _priv":"foobar","public static getPriv":function(){return this.$("_priv")}}),
{"public static getPriv2":function(){return this.getPriv()}});this.assertEqual(a.getPriv(),"foobar","Calls to parent static methods should retain access to their own private members when called externally");this.assertEqual(a.getPriv2(),"foobar","Calls to parent static methods should retain access to their own private members when called internally")}})})(g["test/ClassBuilder/StaticTest"]={},"test/ClassBuilder");(function(c){c.exports={};j=".";document.write("test/ClassBuilder/VisibilityTest...<br />");
f("common").testCase({caseSetUp:function(){this.Sut=this.require("ClassBuilder");this.MethodWrapperFactory=this.require("MethodWrapperFactory");this.wrappers=this.require("MethodWrappers").standard;this.util=this.require("util")},setUp:function(){this.builder=this.Sut(this.require("warn").DismissiveHandler(),this.require("/MemberBuilder")(this.MethodWrapperFactory(this.wrappers.wrapNew),this.MethodWrapperFactory(this.wrappers.wrapOverride),this.MethodWrapperFactory(this.wrappers.wrapProxy),this.getMock("MemberBuilderValidator")),
this.require("/VisibilityObjectFactoryFactory").fromEnvironment())},"Self property references instance rather than property object":function(){var a=null,b=null,d=this.builder.build({"public __construct":function(){a=this.__inst;b=this}})();this.assertDeepEqual(a,d,"this.__inst returns reference to actual instance");!1===this.util.definePropertyFallback()&&this.assertEqual(Object.getOwnPropertyDescriptor(b,"__inst").writable,!1,"this.__inst is not writable")}})})(g["test/ClassBuilder/VisibilityTest"]=
{},"test/ClassBuilder");(function(c){c.exports={};j=".";document.write("test/Class/ConstructorTest...<br />");f("common").testCase({setUp:function(){this.Sut=this.require("class")},"Constructor should not be invoked before instantiation":function(){var a=!1;this.Sut.extend({__construct:function(){a=!0}});this.assertNotEqual(a,!0)},"Constructor should be invoked once upon instantiation":function(){var a=0;new (this.Sut.extend({__construct:function(){a++}}));this.assertEqual(a,1)},"Constructor should be invoked within context of new instance":function(){var a=
Math.random();this.assertEqual((new (this.Sut.extend({val:null,__construct:function(){this.val=a}}))).val,a)},"Constructor arguments should be passed unchanged to __construct":function(){var a=["foo",{bar:"baz"},["moo","cow"]],b=null;new (this.Sut.extend({__construct:function(){b=Array.prototype.slice.call(arguments,0)}}))(a[0],a[1],a[2]);this.assertEqual(b.length,a.length);for(var d=a.length;d--;)this.assertStrictEqual(b[d],a[d],"Ctor argument mismatch: "+d)},"Parent constructor should be invoked for subtype if not overridden":function(){var a=
!1;new (this.Sut.extend({__construct:function(){a=!0}}).extend({}));this.assertOk(a)},"Constructor does not require `new' keyword":function(){var a=this.Sut.extend({});this.assertOk(new a instanceof a);this.assertOk(a()instanceof a)},"__construct must be public":function(){var a=this.Sut;this.assertThrows(function(){a({"protected __construct":function(){}})},TypeError,"Constructor should not be able to be protected");this.assertThrows(function(){a({"private __construct":function(){}})},TypeError,
"Constructor should not be able to be private")},"`constructor' property is properly set to class object":function(){var a=this.Sut.extend({});this.assertStrictEqual(a().constructor,a)}})})(g["test/Class/ConstructorTest"]={},"test/Class");(function(c){c.exports={};j=".";document.write("test/Class/ExtendTest...<br />");f("common").testCase({caseSetUp:function(){this.test_props={one:1,two:2};this.Sut=this.require("class");this.classes=[this.Sut.extend(this.test_props),this.Sut(this.test_props)]},"@each(classes) Created class contains extend method":function(a){this.assertOk("function"===
typeof a.extend)},"@each(classes) Subtype is returned as an object":function(a){this.assertOk(a.extend()instanceof Object)},"@each(classes) Subtype inherits parent properties":function(a){var a=a.extend(),b;for(b in this.test_props)this.assertEqual(this.test_props[b],a.prototype[b],"Missing property: "+b)},"@each(classes) Subtype contains its own properties":function(a){var b={three:3,four:4},a=(new a.extend(b))(),d;for(d in b)this.assertEqual(b[d],a[d],"Missing property: "+d)},"@each(classes) Subtypes are ECMAScript instances of their supertypes":function(a){this.assertOk(a.extend()()instanceof
a)},"@each(classes) Subtypes are easejs instances of their supertypes":function(a){a=a.extend();this.assertOk((new a).isInstanceOf(a))},"@each(classes) Objects are instances of their super-supertypes":function(a){var b=new (a.extend().extend());this.assertOk(b instanceof a&&b.isInstanceOf(a))},"@each(classes) Objects are not instances of subtypes":function(a){var b=a.extend(),a=b.extend(),b=new b;this.assertOk(!(b instanceof a)&&!b.isInstanceOf(a))},"@each(classes) Objects are not instances of sibling types":function(a){var b=
a.extend(),a=b.extend(),b=new (b.extend());this.assertOk(!(b instanceof a)&&!b.isInstanceOf(a))},"Constructor prototype is copied to subclass":function(){var a=function(){};a.prototype={foo:{}};this.assertStrictEqual(this.Sut.extend(a,{}).prototype.foo,a.prototype.foo)},"Subtype of constructor should contain extended members":function(){this.assertNotEqual((new this.Sut.extend(function(){},{foo:{}}))().foo,void 0)},"Subtypes can override parent property values":function(){this.assertEqual(this.Sut.extend({p:null}).extend({p:"ok"})().p,
"ok")},"__initProps() cannot be declared (internal method)":function(){var a=this;this.assertThrows(function(){a.Sut.extend({__initProps:function(){}})},Error)},"Invoking class module requires object as argument if extending":function(){for(var a=this,b=[5,!1,void 0],d=b.length;d--;)this.assertThrows(function(){a.Sut(b[d])},TypeError)},"Can override toString() method":function(){var a="",a=this.Sut("FooToStr",{toString:function(){return"foomookittypoo"}})().toString();this.assertEqual(a,"foomookittypoo")},
"Cannot provide duplicate member definitions using unique keys":function(){var a=this;this.assertThrows(function(){a.Sut({"protected foo":"","public foo":""})},Error);this.assertThrows(function(){a.Sut({"protected foo":function(){},"public foo":function(){}})},Error)},"__construct should not be called when extending class":function(){var a=!1;this.Sut({"public __construct":function(){a=!0}}).extend({});this.assertEqual(a,!1)},"Extending from non-ctor or non-class provides useful error":function(){try{this.Sut.extend("oops",
{})}catch(a){this.assertOk(a.message.search("extend from"),"Error message for extending from non-ctor or class makes sense");return}this.assertFail("Attempting to extend from non-ctor or class should throw exception")},"Extending object will not attempt instantiation":function(){var a={foo:"bar"};this.assertEqual(a.foo,this.Sut.extend(a,{})().foo,"Should be able to use object as prototype")},"Extending validates against non-public super-supertype methods":function(){var a=!1;this.Sut.extend({"virtual protected foo":function(){a=
!0}}).extend({}).extend({"override public foo":function(){this.__super()}})().foo();this.assertOk(a)}})})(g["test/Class/ExtendTest"]={},"test/Class");(function(c){c.exports={};j=".";document.write("test/Class/GeneralTest...<br />");f("common").testCase({setUp:function(){this.Sut=this.require("class");this.Foo=this.Sut.extend({value:"foo"})},"Class module should provide an extend method":function(){this.assertOk("function"===typeof this.Sut.extend)},"Extend method creates a new function":function(){this.assertOk("function"===
typeof this.Foo)},"Classes are considered by the system to be classes":function(){this.assertOk(this.Sut.isClass(this.Foo))},"Only actual classes are considered to be classes":function(){this.assertOk(!this.Sut.isClass({}))},"Class instances are not considered to be classes":function(){this.assertOk(!this.Sut.isClass(new this.Foo))},"Class instances are considered to be instances":function(){this.assertOk(this.Sut.isClassInstance(new this.Foo))},"Classes are not considered to be class instances":function(){this.assertOk(!this.Sut.isClassInstance(this.Foo))},
"Non-class objects are not considered to be instances":function(){this.assertOk(!this.Sut.isClassInstance({}));this.assertOk(!this.Sut.isClassInstance(new function(){}))},"Generated classes should be frozen":function(){void 0!==Object.isFrozen&&this.assertOk(Object.isFrozen(this.Foo))},"Class instance is recognized as instance of class":function(){this.assertOk(this.Sut.isInstanceOf(this.Foo,new this.Foo))},"Checking instance of undefined will not throw an error":function(){this.assertOk(!1===this.Sut.isInstanceOf(this.Foo,
void 0))},"Checking for instance of undefined will not throw an error":function(){this.assertOk(!1===this.Sut.isInstanceOf(void 0,{}))},"Class is not an instance of itself":function(){this.assertOk(!this.Sut.isInstanceOf(this.Foo,this.Foo))},"Class is not an instance of its instance":function(){this.assertOk(!this.Sut.isInstanceOf(new this.Foo,this.Foo))},"isA is an alias for isInstanceOf":function(){this.assertEqual(this.Sut.isInstanceOf,this.Sut.isA)},"Class instance has partially applied isInstanceOf method":function(){var a=
new this.Foo;this.assertOk("function"===typeof a.isInstanceOf&&!0===a.isInstanceOf(this.Foo)&&!1===a.isInstanceOf(a))},"Class instance has partially applied isA alias method":function(){var a=new this.Foo;this.assertEqual(a.isInstanceOf,a.isA)},"Class id is available via class":function(){this.assertOk(void 0!==this.Foo.__cid)},"Class id is available via class prototype":function(){this.assertOk(void 0!==this.Foo.prototype.__cid)}})})(g["test/Class/GeneralTest"]={},"test/Class");(function(c){c.exports=
{};j=".";document.write("test/Class/GetterSetterTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=this.require("class");this.util=this.require("util")},setUp:function(){this.util.definePropertyFallback()&&this.skip();var a={},b={};Object.defineProperty(a,"foo",{get:function(){return this._foo},set:function(a){this._foo=""+a},enumerable:!0});Object.defineProperty(a,"virtual bar",{get:function(){return"durp"},set:function(){},enumerable:!0});Object.defineProperty(b,"override bar",
{get:function(){return this.bar2},set:function(a){this.bar2=a},enumerable:!0});a.bar2="";this.sub=new (this.Sut.extend(a).extend(b))},"Subtypes inherit getters/setters":function(){this.sub.foo="foo";this.assertEqual(this.sub.foo,"foo")},"Subtypes should be able to override getters/setters":function(){this.sub.bar="bar";this.assertEqual(this.sub.bar,"bar");this.assertEqual(this.sub.bar2,"bar")}})})(g["test/Class/GetterSetterTest"]={},"test/Class");(function(c){c.exports={};j=".";document.write("test/Class/ImplementTest...<br />");
f("common").testCase({caseSetUp:function(){this.Class=this.require("class");this.Interface=this.require("interface");this.AbstractClass=this.require("class_abstract");this.Type=this.Interface.extend({"abstract foo":[]});this.Type2=this.Interface.extend({foo2:[]});this.PlainFoo=this.Class.extend()},"Class exports contain implement method for no base class":function(){this.assertOk(this.Class.implement instanceof Function,"Class provides method to implement interfaces")},"Clsss object contains implement method for self as base":function(){this.assertOk(this.PlainFoo.implement instanceof
Function,"Classes contain an implement() method")},"Can implement interface from an empty base":function(){var a=this;this.assertDoesNotThrow(function(){a.Class.implement(a.Type,a.Type2)},Error,"Class can implement interfaces")},"Result of implement is not usable as a class":function(){this.assertEqual(this.Class.isClass(this.Class.implement(this.Type)),!1,"Result of implement operation on class is not usable as a Class")},"Abstract methods are copied into new class using empty base":function(){var a=
this.AbstractClass.implement(this.Type,this.Type2).extend({});this.assertOk(a.prototype.foo instanceof Function&&a.prototype.foo2 instanceof Function,"Abstract methods are copied into the new class prototype (empty base)")},"Can implement interface atop an existing class":function(){var a=this;this.assertDoesNotThrow(function(){a.PlainFoo.implement(a.Type,a.Type2)},Error,"Classes can implement interfaces")},"Implementing interface atop existing class not usable by default":function(){this.assertEqual(this.Class.isClass(this.PlainFoo.implement(this.Type)),
!1,"Result of implementing interfaces on an existing base is not usable as a Class")},"Abstract method copied into new class using existing base":function(){var a=this.AbstractClass.implement(this.Type,this.Type2).extend(this.PlainFoo,{});this.assertOk(a.prototype.foo instanceof Function&&a.prototype.foo2 instanceof Function,"Abstract methods are copied into the new class prototype (concrete base)")},"Classes implementing interfaces are considered abstract by default":function(){this.assertEqual(this.AbstractClass.implement(this.Type).extend({}).isAbstract(),
!0,"Classes that implements interface(s) are considered abstract if the implemented methods have no concrete implementations")},"Instances of classes are instances of their implemented interfaces":function(){var a=this.AbstractClass.implement(this.Type,this.Type2).extend({}).extend({foo:function(){},foo2:function(){}}),b=a();this.assertOk(b.isInstanceOf(this.Type)&&b.isInstanceOf(this.Type2),"Instances of classes implementing interfaces are considered to be instances of the implemented interfaces");
this.assertEqual(a.isAbstract(),!1,"Concrete implementations are not considered to be abstract")},"Cannot specify parent after implementing atop existing class":function(){var a=this.AbstractClass.implement(this.Type,this.Type2).extend(this.PlainFoo,{});this.assertThrows(function(){this.PlainFoo.implement(this.Type,this.Type2).extend(a,{})},Error,"Cannot specify new parent for extend() when implementing from existing class")},"Can specify parent if implementing atop empty class":function(){var a=
this;this.assertDoesNotThrow(function(){a.AbstractClass.implement(a.Type).extend(a.PlainFoo,{})},Error,"Can specify parent for extend() when implementing atop an empty base")},"Throws exception if extend contains too many arguments":function(){var a=this;this.assertThrows(function(){a.Class.implement(a.Type).extend(a.PlainFoo,{},"extra")},Error,"extend() after implementing accepts no more than two args")}})})(g["test/Class/ImplementTest"]={},"test/Class");(function(c){c.exports={};j=".";document.write("test/Class/InstanceSafetyTest...<br />");
f("common").testCase({caseSetUp:function(){this.Sut=this.require("class")},"Multiple instances of same class do not share array references":function(){var a=this.Sut.extend({arr:[]}),b=new a,a=new a;b.arr.push("one");a.arr.push("two");this.assertEqual(b.arr[0],"one");this.assertEqual(a.arr[0],"two");this.assertEqual(b.arr.length,1);this.assertEqual(a.arr.length,1)},"Multiple instances of same class do not share object references":function(){var a=this.Sut.extend({obj:{}}),b=new a,a=new a;b.obj.a=
!0;a.obj.b=!0;this.assertEqual(b.obj.a,!0);this.assertEqual(b.obj.b,void 0);this.assertEqual(a.obj.a,void 0);this.assertEqual(a.obj.b,!0)},"Instances of subtypes do not share property references":function(){var a=this.Sut.extend({arr:[],obj:{}}).extend({}),b=new a,a=new a;this.assertNotEqual(b.arr!==a.arr);this.assertNotEqual(b.obj!==a.obj)}})})(g["test/Class/InstanceSafetyTest"]={},"test/Class");(function(c){c.exports={};j=".";document.write("test/Class/InteropTest...<br />");f("common").testCase({caseSetUp:function(){this.Class=
this.require("class");this.fallback=this.require("util").definePropertyFallback()},"Methods inherited from a prototype are implicitly virtual":function(){var a={},b=function(){this.foo=function(){return null}},d=this.Class,e;this.assertDoesNotThrow(function(){e=d.extend(b,{"override foo":function(){return a}})()});this.assertStrictEqual(e.foo(),a)},"Prototype method overrides must provide override keyword":function(){var a=function(){this.foo=function(){}},b=this.Class;this.assertThrows(function(){b.extend(a,
{foo:function(){}})})},"Recognizes and proxies prototype properties as public":function(){var a=this.Class.extend(function(){this.foo="bar";this.updateFoo=function(a){this.foo=a}},{"override updateFoo":function(a){this.__super(a);return this},ownUpdateFoo:function(a){this.foo=a;return this}})();this.assertEqual(a.ownUpdateFoo("baz").foo,"baz");this.assertEqual(a.updateFoo("buzz").foo,"buzz")},"Does not recognize non-ctor-initialized properties as public":function(){if(!this.fallback){var a=this.Class.extend(function(){this.init=
function(a){this.foo=a;return this}},{rmfoo:function(){this.foo=void 0;return this},getFoo:function(){return this.foo}})();this.assertEqual(a.init("bar").rmfoo().foo,"bar");this.assertEqual(a.getFoo(),void 0)}},"Declaring non-ctor-initialized properties as public resolves proxy":function(){this.assertEqual(this.Class.extend(function(){this.init=function(){this.foo=null;return this}},{"public foo":null,setFoo:function(a){this.foo=a;return this}})().init().setFoo("bar").foo,"bar")},"Cannot de-escalate visibility of prototype properties":function(){var a=
function(){this.foo="bar"},b=this.Class;this.assertThrows(function(){b.extend(a,{"protected foo":""})})},"Returning `this` from prototype method yields public obj":function(){var a=this.Class.extend(function(){this.pub=function(){return this}},{})();this.assertStrictEqual(a.pub(),a)},"Subtypes of prototype subtypes yield stable classes":function(){var a={},b=this.Class.extend(function(){},{}).extend({foo:function(){return a}}),d=b();this.assertOk(this.Class.isClass(b));this.assertOk(this.Class.isClassInstance(d));
this.assertOk(this.Class.isA(b,d));this.assertStrictEqual(d.foo(),a)},"Can defer invoking __construct":function(){var a={},b=this.Class({__construct:function(){throw Error("__construct called!");},foo:function(){return a}}),d;this.assertDoesNotThrow(function(){d=b.asPrototype()});this.assertOk(this.Class.isA(b,d));this.assertStrictEqual(a,d.foo())},"Can invoke constructor within context of prototypal subtype":function(){function a(){this.__construct.call(this)}var b={},d=this.Class({foo:null,__construct:function(){this.foo=
b}});a.prototype=d.asPrototype();this.assertStrictEqual((new a).foo,b)},"Deferred constructor still has access to private context":function(){function a(){this.__construct.call(this)}var b={},d=this.Class({"private _foo":null,__construct:function(){this._foo=b},getFoo:function(){return this._foo}});a.prototype=d.asPrototype();this.assertStrictEqual((new a).getFoo(),b)}})})(g["test/Class/InteropTest"]={},"test/Class");(function(c){c.exports={};j=".";document.write("test/Class/NameTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=
this.require("class");this.AbstractClass=this.require("class_abstract")},"Class defined with name is returned as a valid class":function(){this.assertOk(this.Sut.isClass(this.Sut("Foo",{})))},"Named class definition requires that field definition be an object":function(){try{this.Sut("Foo","Bar"),this.assertFail("Second argument to named class must be the definition")}catch(a){this.assertNotEqual(a.message.match("Foo"),null,"Error string contains class name")}},"Named class definition is strict on argument count":function(){var a=
["Foo",{},"extra"];try{this.Sut.apply(null,a),this.assertFail("Should accept only two arguments when creating named class")}catch(b){var d=b.message;this.assertNotEqual(d.match("Foo"),null,"Named class error should provide name of class");this.assertNotEqual(d.match(a.length+" given"),null,"Named class error should provide number of given arguments")}},"Converting anonymous class to string yields class string":function(){this.assertEqual(this.Sut({}).toString(),"(Class)")},"Converting abstract anonymous class to string yields class string":function(){this.assertEqual(this.AbstractClass({"abstract foo":[]}).toString(),
"(AbstractClass)")},"Converting named class to string yields string containing name":function(){this.assertEqual(this.Sut("Foo",{}).toString(),"Foo");this.assertEqual(this.AbstractClass("Foo",{"abstract foo":[]}).toString(),"Foo")},"Converting class instance to string yields instance string":function(){var a=this.Sut({})(),b=this.Sut("Foo",{})();this.assertEqual(a.toString(),"#<anonymous>");this.assertEqual(b.toString(),"#<Foo>")},"Can create named class using staging method":function(){var a=this.Sut("Foo").extend({});
this.assertEqual(this.Sut.isClass(a),!0,"Named class generated via staging method is considered to be a valid class");this.assertEqual(a.toString(),"Foo","Name is set on named clas via staging method")},"Can implement interfaces using staging method":function(){var a=this.require("interface"),a=this.Sut("Foo").implement(a({})).extend({});this.assertEqual(this.Sut.isClass(a),!0,"Named class generated via staging method, implementing an interface, is considered to be a valid class");this.assertEqual(a.toString(),
"Foo","Name is set on named class via staging method when implementing")},"Can extend existing classes using staging method":function(){var a=this.Sut("Foo").extend({}),b=this.Sut("Foo").extend(a,{});this.assertEqual(this.Sut.isClass(b),!0);this.assertOk(this.Sut.isInstanceOf(a,b()));this.assertEqual(b.toString(),"Foo")},"Class name is given when attempting to instantiate abstract class":function(){try{this.Sut("Foo",{"abstract foo":[]})(),this.assertFail("Was expecting instantiation error; there's a bug somewhere")}catch(a){this.assertNotEqual(a.message.match("Foo"),
null,"Abstract class instantiation error should contain class name")}try{this.Sut({"abstract foo":[]})(),this.assertFail("Was expecting instantiation error; there's a bug somewhere")}catch(b){this.assertNotEqual(b.message.match("(anonymous)"),null,"Abstract class instantiation error should recognize that class is anonymous if no name was given")}}})})(g["test/Class/NameTest"]={},"test/Class");(function(c){c.exports={};j=".";document.write("test/Class/ParentTest...<br />");f("common").testCase({setUp:function(){this.Sut=
this.require("class")},"Subtype does not invoke overridden parent method by default":function(){var a=!1;this.Sut({"virtual foo":function(){a=!0}}).extend({"override foo":function(){}})().foo();this.assertOk(!a)},"Subtype can invoke parent method with arguments":function(){var a=null;this.Sut({"virtual foo":function(b,d){a=[b,d]}}).extend({"override foo":function(a,d){this.__super(a,d)}})().foo("foobar","baz");this.assertNotEqual(a,null);this.assertEqual(a[0],"foobar");this.assertEqual(a[1],"baz")}})})(g["test/Class/ParentTest"]=
{},"test/Class");(function(c){c.exports={};j=".";document.write("test/Class/VisibilityTest...<br />");var a=function(){return"foo"},b=function(){return"bar"},d=function(){return"baz"};f("common").testCase({caseSetUp:function(){this.Class=this.require("class");this.Interface=this.require("interface");this.util=this.require("util");this.Foo=this.Class.extend({"public pub":"foo","protected peeps":"bar","private parts":"baz","public pubf":a,"protected protf":b,"private privf":d,"virtual public getProp":function(a){return this[a]},
"public nonOverrideGetProp":function(a){return this[a]},"public setValue":function(a,b){this[a]=b},"public getSelf":function(){return this},"virtual public getSelfOverride":function(){},"public getPrivProp":function(){return this.parts},"public invokePriv":function(){return this._priv()},"private _priv":function(){return"baz"}});this.SubFoo=this.Foo.extend({"private _pfoo":"baz","override public getSelfOverride":function(){return this},"override public getProp":function(a){return this[a]},"private myOwnPrivateFoo":function(){}})},
setUp:function(){this.foo=this.Foo();this.sub_foo=this.SubFoo()},"Public members are accessible externally":function(){this.assertEqual(this.foo.pub,"foo","Public properties are accessible via public interface");this.assertEqual(this.foo.pubf(),"foo","Public methods are accessible via public interface")},"Public members are accessible internally":function(){this.assertEqual(this.foo.getProp("pub"),"foo","Public properties are accessible internally");this.assertEqual(this.foo.getProp("pubf")(),"foo",
"Public methods are accessible internally")},"Public properties are writable internally":function(){this.foo.setValue("pub","moomookittypoo");this.assertEqual(this.foo.getProp("pub"),"moomookittypoo","Setting the value of a public property internally should be observable /internally/");this.assertEqual(this.foo.pub,"moomookittypoo","Setting the value of a public property internally should be observable /externally/")},"Protected and private members are not accessible externally":function(){this.util.definePropertyFallback()||
(this.assertEqual(this.foo.peeps,void 0,"Protected properties are inaccessible via public interface"),this.assertEqual(this.foo.parts,void 0,"Private properties are inaccessible via public interface"),this.assertEqual(this.foo.protf,void 0,"Protected methods are inaccessible via public interface"),this.assertEqual(this.foo.privf,void 0,"Private methods are inaccessible via public interface"))},"Protected members are accessible internally":function(){this.assertEqual(this.foo.getProp("peeps"),"bar",
"Protected properties are available internally");this.assertEqual(this.foo.getProp("protf")(),"bar","Protected methods are available internally")},"Private members are accessible internally":function(){this.assertEqual(this.foo.getProp("parts"),"baz","Private properties are available internally");this.assertEqual(this.foo.getProp("privf")(),"baz","Private methods are available internally")},"Protected members are inherited from parent":function(){this.assertEqual(this.sub_foo.getProp("peeps"),"bar",
"Protected properties are available to subtypes");this.assertEqual(this.sub_foo.getProp("protf")(),"bar","Protected methods are available to subtypes")},"Private members of supertypes are inaccessible to subtypes":function(){this.util.definePropertyFallback()||(this.assertEqual(this.sub_foo.getProp("parts"),void 0,"Private properties of supertypes should be unavailable to subtypes"),this.assertEqual(this.sub_foo.getProp("privf"),void 0,"Private methods of supertypes should be unavailable to subtypes"))},
"Protected members are not shared between class instances":function(){this.foo.setValue("prot","foobar");this.assertNotEqual(this.sub_foo.getProp("prot"),"foobar","Class instances do not share protected values (subtype)");this.SubFoo().setValue("prot","foobar");this.assertNotEqual(this.sub_foo.getProp("prot"),"foobar","Class instances do not share protected values (same type)")},"Returning self from method should return instance not prop obj":function(){this.assertDeepEqual(this.foo.getSelf(),this.foo,
"Returning 'this' from a method should return instance of self");this.assertDeepEqual(this.sub_foo.getSelf(),this.sub_foo,"Returning 'this' from a super method should return the subtype");this.assertDeepEqual(this.sub_foo.getSelfOverride(),this.sub_foo,"Returning 'this' from a overridden method should return subtype")},"Parent methods can access private members of parent":function(){this.assertEqual(this.sub_foo.getPrivProp(),"baz","Parent methods should have access to the private properties of the parent");
this.assertEqual(this.sub_foo.invokePriv(),"baz","Parent methods should have access to the private methods of the parent");var a=this.SubFoo.extend({})();this.assertEqual(a.getPrivProp(),"baz","Parent methods should have access to the private properties of the parent (2)");this.assertEqual(a.invokePriv(),"baz","Parent methods should have access to the private methods of the parent (2)")},"Parents should not have access to private members of subtypes":function(){this.util.definePropertyFallback()||
(this.assertEqual(this.sub_foo.nonOverrideGetProp("_pfoo"),void 0,"Parent should not have access to private properties of subtype whena parent method is invoked"),this.assertEqual(this.sub_foo.nonOverrideGetProp("_myOwnPrivateFoo"),void 0,"Parent should not have access to private methods of subtype when a parent method is invoked"))},"Can escalate member visibility":function(){var a=this;this.assertDoesNotThrow(function(){a.Class({"protected foo":"bar","virtual protected baz":function(){}}).extend({"public foo":"bar",
"override public baz":function(){}})},Error,"Can escalate visibility of subtype members");this.assertDoesNotThrow(function(){a.Class({"protected foo":"bar","virtual protected baz":function(){}}).extend({"protected foo":"bar","override protected baz":function(){}})},Error,"Can retain level of visibility for subtype members")},"Cannot de-escalate member visibility":function(){var a=this;this.assertThrows(function(){a.Class({"public foo":"bar"}).extend({"protected foo":"bar"})},Error,"Cannot de-escalate visibility of sub-props to protected");
this.assertThrows(function(){a.Class({"virtual public baz":function(){}}).extend({"protected baz":function(){}})},Error,"Cannot de-escalate visibility of sub-methods to protected");this.assertThrows(function(){a.Class({"public foo":"bar"}).extend({"private foo":"bar"})},Error,"Cannot de-escalate visibility of subtype props to private");this.assertThrows(function(){a.Class({"virtual public baz":function(){}}).extend({"private baz":function(){}})},Error,"Cannot de-escalate visibility of sub-methods to private");
this.assertThrows(function(){a.Class({"protected foo":"bar"}).extend({"private foo":"bar"})},Error,"Cannot de-escalate visibility of sub-props to private2");this.assertThrows(function(){a.Class({"virtual protected baz":function(){}}).extend({"private baz":function(){}})},Error,"Cannot de-escalate visibility of sub-methods to private2")},"Calling super method works properly with protected methods":function(){this.assertEqual(this.Class({"virtual protected foo":function(){return"foobar"}}).extend({"override public foo":function(){return this.__super()}})().foo(),
"foobar","__super() calls work with protected overrides")},"Visibility de-escalation rulse apply to interfaces":function(){var a=this;this.assertThrows(function(){Class.implement(a.Interface({"abstract public foo":[]})).extend({"protected foo":function(){}})},Error,"Cannot de-escalate visibility for interface members")},"Can override protected method functionality with public":function(){this.assertEqual(this.Class({"virtual protected foo":function(){return!1}}).extend({"override public foo":function(){return!0}})().foo(),
!0,"Can properly override protected methods with public")},"Protected method overrides are observable by supertype":function(){var a=this,b=!1;this.Class({"public doFoo":function(){return this.foo()},"virtual protected foo":function(){a.fail(!0,!1,"Method not overridden")}}).extend({"public override foo":function(){b=!0}})().doFoo();this.assertOk(b)},"Protected values are available to subtypes when set by parent":function(){this.assertEqual(this.Class({"protected val":0,"public __construct":function(){this.val=
5}}).extend({"public getVal":function(){return this.val}})().getVal(),5,"Subtypes should have acess to protected properties values set by super methods")},"Can properly override protected with protected":function(){this.assertEqual(this.Class({"virtual protected foo":function(){}}).extend({"override protected foo":function(){return"foobar"},"public doFoo":function(){return this.foo()}})().doFoo(),"foobar","Protected methods can properly be overriden by another protected method")}})})(g["test/Class/VisibilityTest"]=
{},"test/Class");(function(c){c.exports={};j=".";document.write("test/FallbackMemberBuilderTest...<br />");f("./common").testCase({setUp:function(){var a=this.require("MethodWrapperFactory")(function(a){return a});this.sut=this.require("FallbackMemberBuilder")(a,a)},"Inherits from MemberBuilder":function(){this.assertOk(this.sut instanceof this.require("MemberBuilder"),"FallbackMemberBuilder should inherit from MemberBuilder")},"buildGetterSetter() method throws an exception":function(){try{this.sut.buildGetterSetter(),
this.fail("Exception should have been called (getter/setter)")}catch(a){this.assertOk(a.message.match(/unsupported/),"Incorrect exception thrown (getter/setter)")}}})})(g["test/FallbackMemberBuilderTest"]={},"test");(function(c){c.exports={};j=".";document.write("test/FallbackVisibilityObjectFactoryTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=this.require("FallbackVisibilityObjectFactory");this.VisibilityObjectFactory=this.require("VisibilityObjectFactory");this.props=this.methods=
{"public":{},"protected":{},"private":{}}},"Can instantiate with and without `new` keyword":function(){this.assertOk(new this.Sut instanceof this.Sut,"Should be able to instantiate FallbackVisibilityObjectFactory with 'new' keyword");this.assertOk(this.Sut()instanceof this.Sut,"Should be able to instantiate FallbackVisibilityObjectFactory without 'new' keyword")},"Inherits from visibility object factory":function(){this.assertOk(this.Sut()instanceof this.VisibilityObjectFactory,"Fallback should inherit from VisibilityObjectFactory")},
"Setup method should not add private layer":function(){var a={},b=this.Sut().setup(a,this.props,this.methods);this.assertStrictEqual(a,b,"Private visibility layer is not added atop destination")},"Creating property proxy should simply return self":function(){var a={};this.assertStrictEqual(this.Sut().createPropProxy(a,{},this.props),a,"Creating property proxy should simply return original object")}})})(g["test/FallbackVisibilityObjectFactoryTest"]={},"test");(function(c){c.exports={};j=".";document.write("test/Interface/ExtendTest...<br />");
var c=f("common"),a=c.require("interface"),b=!c.require("util").definePropertyFallback();c.testCase({caseSetUp:function(){this.baseTypes=[a.extend({method:[]}),a({method:[]})];this.invalidExtend=["moo",5,!1,void 0];this.badAm=["protected","private"]},"Properties are not permitted within interfaces":function(){this.assertThrows(function(){a.extend({prop:"not permitted"})},TypeError,"Properties are not permitted within Interface definitions")},"Getters are setters are not permitted within intefaces":function(){if(b){var d=
{};Object.defineProperty(d,"foo",{get:function(){},set:function(){},enumerable:!0});this.assertThrows(function(){a.extend(d)},TypeError,"Getters/setters not permitted within Interfaces")}},"Concrete methods are not permitted":function(){this.assertThrows(function(){a.extend({method:function(){}})},TypeError,"Concrete methods are not permitted within Interface definitions")},"Method declarations (using arrays) are permitted":function(){this.assertDoesNotThrow(function(){a.extend({method:[]})},TypeError,
"Abstract method declarations are allowed within Interface definitions")},"@each(baseTypes) Interface contains defined abstract methods":function(a){this.assertOk("function"===typeof a.prototype.method,"Interface should contain defined abstract methods")},"@each(baseTypes) Result is considered to be an interface":function(b){this.assertEqual(a.isInterface(b),!0)},"@each(baseTypes) Can extend interface using Interface.extend()":function(b){this.assertOk(a.extend(b,{}).prototype instanceof b,"Generic interface extend method should be able to extend from other interfaces")},
"@each(baseTypes) Interface subtypes inherit abstract methods":function(b){this.assertOk(a.extend(b,{}).prototype.method===b.prototype.method,"Interface subtypes inherit abstract methods")},"@each(baseTypes) Interfaces can extend the API with abstract methods":function(b){this.assertOk("function"===typeof a.extend(b,{second:[]}).prototype.second,"Should be able to extend interfaces with additional abstract methods")},"@each(baseTypes) Interfaces contain an extend() method":function(a){this.assertOk("function"===
typeof a.extend,"Interface should contain extend() method")},"@each(baseTypes) extend() method on interface itself can extend":function(a){this.assertOk(a.extend({}).prototype instanceof a,"Interface extend method can extend interfaces")},"@each(baseTypes) Interface's extend() method can add to the API":function(a){this.assertOk("function"===typeof a.extend({second:[]}).prototype.second,"Interfaces should be able to be extended with additional abstract methods using shorthand extend method")},"@each(invalidExtend) Invoking module to extend requires object":function(b){this.assertThrows(function(){a(b)},
TypeError,"Invoking interface module should require object as argument if extending from base interface")},"Only one argment for interface definitions is permitted":function(){var b=[{},"one","two","three"];try{a.apply(null,b),this.fail("Only one argument for interface definitions should be permitted")}catch(c){this.assertOk(-1<c.message.search(b.length+" given"),"Interface invocation should give argument count on error")}},"@each(badAm) Interface members must be public":function(b){this.assertThrows(function(){var c=
{};c[b+" foo"]=[];a(c)},Error,"Interface members should not be able to be "+b)},"Interfaces can only extend interfaces":function(){this.assertThrows(function(){a.extend(function(){},{})},TypeError,"Should not be able to extend from non-interface")}})})(g["test/Interface/ExtendTest"]={},"test/Interface");(function(c){c.exports={};j=".";document.write("test/Interface/GeneralTest...<br />");f("common").testCase({setUp:function(){this.FooType=this.require("interface").extend()},"Interface extend method creates a new interface object":function(){this.assertOk("function"===
typeof this.FooType,"Interface extend method creates a new interface object")},"Interfaces cannot be instantiated":function(){this.assertThrows(function(){new this.FooType},Error,"Should not be able to instantiate interfaces")},"Generated interface should be frozen":function(){Object.isFrozen&&this.assertEqual(Object.isFrozen(this.FooType),!0,"Generated interface object should be frozen")}})})(g["test/Interface/GeneralTest"]={},"test/Interface");(function(c){c.exports={};j=".";document.write("test/Interface/InteropTest...<br />");
f("common").testCase({caseSetUp:function(){this.Sut=this.require("interface");this.Class=this.require("class");this.I=this.Sut({foo:["a","b"],bar:["a"]});this.assertICompat=function(a,b){this.assertOk(a.isCompatible(b));this.assertOk(this.Sut.isInstanceOf(a,b))};this.assertNotICompat=function(a,b){this.assertOk(!a.isCompatible(b));this.assertOk(!this.Sut.isInstanceOf(a,b))}},"Prototype instances and objects can conform to interfaces":function(){function a(){}a.prototype={foo:function(){},bar:function(){}};
this.assertICompat(this.I,new a);this.assertICompat(this.I,a.prototype)},"Objects missing methods are non-conforming":function(){function a(){}a.prototype={foo:function(){}};this.assertNotICompat(this.I,new a);this.assertNotICompat(this.I,a.prototype)},"Methods missing parameters are non-conforming":function(){this.assertNotICompat(this.Sut({foo:["a","b"]}),{foo:function(){}})},"Methods are still compatible with extra parameters":function(){this.assertICompat(this.Sut({foo:["a","b"]}),{foo:function(){}})},
"Interface methods must be implemented as functions":function(){this.assertNotICompat(this.Sut({foo:[]}),{foo:{}})},"Additional methods do not trigger incompatibility":function(){this.assertICompat(this.Sut({foo:[]}),{foo:function(){},bar:function(){}})},"Objects can be compatible but not instances of interface":function(){var a=this.Sut({foo:[]}),b=this.Sut({foo:[]}),d={foo:function(){}},c=this.Class.implement(a).extend(d),d=this.Class.implement(b).extend(d),c=c(),d=d();this.assertOk(a.isCompatible(c));
this.assertOk(a.isCompatible(d));this.assertOk(b.isCompatible(c));this.assertOk(b.isCompatible(d));this.assertOk(this.Sut.isInstanceOf(a,c));this.assertOk(!this.Sut.isInstanceOf(a,d));this.assertOk(this.Sut.isInstanceOf(b,d));this.assertOk(!this.Sut.isInstanceOf(b,c))}})})(g["test/Interface/InteropTest"]={},"test/Interface");(function(c){c.exports={};j=".";document.write("test/Interface/NameTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=this.require("interface");this.util=this.require("util")},
"Interface accepts name":function(){var a=this;this.assertDoesNotThrow(function(){var b=a.Sut("Foo",{});a.assertOk(a.Sut.isInterface(b))},Error)},"Named interface definition requires that definition be an object":function(){try{this.Sut("Foo","Bar"),this.assertFail("Second argument to named interface must be the definition")}catch(a){this.assertNotEqual(a.message.match("Foo"),null,"Interface definition argument count error string contains interface name")}},"Named interface definition is strict on argument count":function(){var a=
["Foo",{},"extra"];try{this.Sut.apply(null,a),assert.fail("Should accept only two arguments when creating named interface")}catch(b){var d=b.message;this.assertNotEqual(d.match("Foo"),null,"Named interface error should provide interface name");this.assertNotEqual(d.match(a.length+" given"),null,"Named interface error should provide number of given arguments")}},"Converting anonymous interface to string yields generic string":function(){this.assertEqual(this.Sut({}).toString(),"[object Interface]")},
"Converting named interface to string yields string containing name":function(){this.assertEqual(this.Sut("Foo",{}).toString(),"[object Interface <Foo>]")},"Declaration errors provide interface name if avaiable":function(){var a=this.Sut,b=[function(){a("Foo",{prop:"str"})},function(){a("Foo",{method:function(){}})}];this.util.definePropertyFallback()||(b.push(function(){var b={};Object.defineProperty(b,"getter",{get:function(){},enumerable:!0});a("Foo",b)}),b.push(function(){var b={};Object.defineProperty(b,
"setter",{set:function(){},enumerable:!0});a("Foo",b)}));for(var d=b.length;d--;){try{b[d]()}catch(c){this.assertNotEqual(c.message.match("Foo"),null,"Error contains interface name when available ("+d+")");break}this.assertFail("Expected error. Something's wrong: "+d)}},"Interface name is included in instantiation error":function(){try{this.Sut("Foo")(),this.assertFail("Exception expected. There's a bug somewhere.")}catch(a){this.assertNotEqual(a.message.match("Foo"),null,"Interface name is included in instantiation error message")}}})})(g["test/Interface/NameTest"]=
{},"test/Interface");(function(c,a){c.exports={};j=".";document.write("test/MemberBuilder/GetterSetterTest...<br />");var b=f("common"),d=f(a+"/inc-common"),e=!b.require("util").definePropertyFallback();f("common").testCase({caseSetUp:function(){var a=this;this.testArgs=function(b,c,e,f,g){d.testArgs(a,b,c,e,f,g,function(b,d,e){var h=a.members["public"][c];return!h?b:{value:{expected:h,given:d.member},keywords:{expected:null,given:e}}})}},setUp:function(){var a=this.require("MethodWrapperFactory")(function(a){return a});
this.sut=this.require("MemberBuilder")(a,a,a,this.mockValidate=this.getMock("MemberBuilderValidator"));this.members=this.sut.initMembers()},"Passes proper data to validator when not overriding":function(){e||this.skip();var a=this,b=!1,d={};this.mockValidate.validateGetterSetter=function(){b=!0;a.testArgs(arguments,"foo",{},d)};this.sut.buildGetterSetter(this.members,{},"foo",function(){},function(){},d,{});this.assertEqual(!0,b,"validateGetterSetter() was not called")},"Passes proper data to validator when overriding":function(){e||
this.skip();var a=this,b=!1,d={};this.members["public"].foo={};this.mockValidate.validateGetterSetter=function(){b=!0;a.testArgs(arguments,"foo",{},d)};this.sut.buildGetterSetter(this.members,{},"foo",function(){},function(){},d,{});this.assertEqual(!0,b,"validateGetterSetter() was not called")}})})(g["test/MemberBuilder/GetterSetterTest"]={},"test/MemberBuilder");(function(c,a){c.exports={};j=".";document.write("test/MemberBuilder/MethodTest...<br />");var b=f(a+"/inc-common");f("common").testCase({caseSetUp:function(){var a=
this;this.testArgs=function(c,i,h,f,g){b.testArgs(a,c,i,h,f,g,function(b,c,e){var h=a.members["public"][i];return!h?b:{value:{expected:h,given:c.member},keywords:{expected:h.___$$keywords$$,given:e}}})};this.weakab=[]},setUp:function(){var a=this,b=this.require("MethodWrapperFactory")(function(a){return function(){return a()}}),c=this.require("MethodWrapperFactory")(function(){a.proxyFactoryCall=Array.prototype.slice.call(arguments);return a.proxyReturnValue});this.proxyFactoryCall=null;this.proxyReturnValue=
function(){};this.sut=this.require("MemberBuilder")(b,b,c,this.mockValidate=this.getMock("MemberBuilderValidator"));this.members=this.sut.initMembers()},"Passes proper data to validator when not overriding":function(){var a=this,b=!1,c=function(){},h={},f={};this.mockValidate.validateMethod=function(){b=!0;a.testArgs(arguments,"foo",c,f,h)};this.assertOk(this.sut.buildMethod(this.members,{},"foo",c,f,function(){},1,{},h));this.assertEqual(!0,b,"validateMethod() was not called")},"Passes proper data to validator when overriding":function(){var a=
this,b=!1,c=function(){},h={override:!0};(this.members["public"].foo=function(){}).___$$keywords$$={"public":!0};this.mockValidate.validateMethod=function(){b=!0;a.testArgs(arguments,"foo",c,h)};this.assertOk(this.sut.buildMethod(this.members,{},"foo",c,h,function(){},1,{}));this.assertEqual(!0,b,"validateMethod() was not called")},"Creates proxy when `proxy' keyword is given":function(){var a={proxy:!0},b=function(){};this.assertOk(this.sut.buildMethod(this.members,{},"foo","bar",a,b,1,{}));this.assertNotEqual(null,
this.proxyFactoryCall,"Proxy factory should be used when `proxy' keyword is provided");this.assertDeepEqual(["bar",null,1,b,"foo",a],this.proxyFactoryCall,"Proxy factory should be called with proper arguments");this.assertStrictEqual(this.proxyReturnValue,this.members["public"].foo,"Generated proxy method should be properly assigned to members")},"Weak abstract methods are not processed if concrete is available":function(){var a=!1,b=[],c={weak:!0,"abstract":!0},h=function(){};this.assertOk(this.sut.buildMethod(this.members,
{},"foo",b,c,h,1,{}));this.assertOk(this.sut.buildMethod(this.members,{},"foo",function(){a=!0},{},h,1,{}));this.members["public"].foo();this.assertOk(a,"Concrete method did not take precedence");this.assertOk(!1===this.sut.buildMethod(this.members,{},"foo",b,c,h,1,{}));this.members["public"].foo();this.assertOk(a,"Concrete method unkept")},"Weak virtual methods are not processed if override is available":function(){var a=this,b=!1,c=function(){a.fail(!0,!1,"Method not overridden.")},h={weak:!0,virtual:!0},
f=function(){};this.assertOk(this.sut.buildMethod(this.members,{},"foo",c,h,f,1,{}));this.assertOk(this.sut.buildMethod(this.members,{},"foo",function(){b=!0},{override:!0},f,1,{}));this.members["public"].foo();this.assertOk(b,"Override did not take precedence");this.assertOk(!1===this.sut.buildMethod(this.members,{},"foo",c,h,f,1,{}));this.members["public"].foo();this.assertOk(b,"Override unkept")},"Private methods are not wrapped":function(){var a=function(){};this.sut.buildMethod(this.members,
{},"foo",a,{"private":!0},function(){},1,{});this.assertStrictEqual(this.members["private"].foo,a)}})})(g["test/MemberBuilder/MethodTest"]={},"test/MemberBuilder");(function(c,a){c.exports={};j=".";document.write("test/MemberBuilder/PropTest...<br />");var b=f(a+"/inc-common");f("common").testCase({caseSetUp:function(){var a=this;this.testArgs=function(c,i,h,f,g){b.testArgs(a,c,i,h,f,g,function(b,c,e){var h=a.members["public"][i];return!h?b:{value:{expected:h[0],given:c.member[0]},keywords:{expected:h[1],
given:e}}})}},setUp:function(){var a=this.require("MethodWrapperFactory")(function(a){return a});this.sut=this.require("MemberBuilder")(a,a,a,this.mockValidate=this.getMock("MemberBuilderValidator"));this.members=this.sut.initMembers()},"Passes proper data to validator when not overriding":function(){var a=this,b=!1,c={};this.mockValidate.validateProperty=function(){b=!0;a.testArgs(arguments,"foo","bar",c)};this.sut.buildProp(this.members,{},"foo","bar",c,{});this.assertEqual(!0,b,"validateProperty() was not called")},
"Passes proper data to validator when overriding":function(){var a=this,b=!1,c={};this.members["public"].foo=["prev",{"public":!0}];this.mockValidate.validateProperty=function(){b=!0;a.testArgs(arguments,"foo","bar2",c)};this.sut.buildProp(this.members,{},"foo","bar2",c,{});this.assertEqual(!0,b,"validateProperty() was not called")}})})(g["test/MemberBuilder/PropTest"]={},"test/MemberBuilder");(function(c,a){c.exports={};j=".";document.write("test/MemberBuilderValidator/GetterSetterTest...<br />");
var b=f(a+"/inc-common");f("common").testCase({caseSetUp:function(){var a=this;this.quickFailureTest=function(){b.quickFailureTest.apply(a,arguments)};this.quickKeywordTest=function(a,d,c){b.quickKeywordTest.call(this,"validateGetterSetter",a,d,c,c&&{get:function(){},set:function(){}})};this.quickVisChangeTest=function(c,i,h,f){b.quickVisChangeTest.call(a,c,i,h,function(b,c,e){c.virtual=!0;e.override=!0;a.sut.validateGetterSetter(b,{},e,{get:function(){},set:function(){}},c)},f)}},setUp:function(){var a=
this;this.warningHandler=function(){};this.sut=this.require("MemberBuilderValidator")(function(b){a.warningHandler(b)})},"Cannot override method with getter or setter":function(){var a=this;this.quickFailureTest("foo","method",function(){a.sut.validateGetterSetter("foo",{},{},{member:function(){}})})},"Cannot override property with getter or setter":function(){var a=this;this.quickFailureTest("foo","method",function(){a.sut.validateGetterSetter("foo",{},{},{member:"foo"})})},"Getters/setters do not support visibility de-escalation":function(){this.quickVisChangeTest("public",
"protected",!0);this.quickVisChangeTest("protected","private",!0)},"Getters/setters support visibility escalation and equality":function(){var a=this;b.visEscalationTest(function(b){a.quickVisChangeTest(b[0],b[1],!1)})},"Cannot redeclare private getters/setters in subtypes":function(){var a=this;b.privateNamingConflictTest(function(b){a.quickVisChangeTest(b[0],b[1],!0,"conflict")})},"Cannot declare abstract getters/setters":function(){this.quickKeywordTest(["abstract"],"abstract")},"Cannot declare const getters/setters":function(){this.quickKeywordTest(["const"],
"const")},"Can override virtual getter/setter with override keyword":function(){this.quickKeywordTest(["override"],null,["virtual"])},"Must provide override keyword when overriding getter/setter":function(){this.quickKeywordTest([],"override",["virtual"])},"Cannot override non-virtual getter/setter":function(){this.quickKeywordTest(["override"],"non-virtual",[])},"Can declare getter/setter as static":function(){this.quickKeywordTest(["static"])},"Cannot declare getter/setter as both static and virtual":function(){this.quickKeywordTest(["static",
"virtual"],"static")},"Throws warning when using override with no super getter/setter":function(){var a=null;this.warningHandler=function(b){a=b};this.quickKeywordTest(["override"]);this.assertNotEqual(null,a,"No warning was provided");this.assertOk(a instanceof Error,"Provided warning is not of type Error");this.assertOk(-1<a.message.search(b.testName),"Override warning should contain getter/setter name")}})})(g["test/MemberBuilderValidator/GetterSetterTest"]={},"test/MemberBuilderValidator");(function(c,
a){c.exports={};j=".";document.write("test/MemberBuilderValidator/MethodTest...<br />");var b=f(a+"/inc-common");f("common").testCase({caseSetUp:function(){var a=this;this.util=this.require("util");this.quickKeywordMethodTest=function(a,d,c){b.quickKeywordTest.call(this,"validateMethod",a,d,c)};this.quickFailureTest=function(){b.quickFailureTest.apply(a,arguments)};this.quickVisChangeTest=function(c,i,h,f){b.quickVisChangeTest.call(a,c,i,h,function(b,c,e){c.virtual=!0;e.override=!0;var i={};a.sut.validateMethod(b,
function(){},e,{member:function(){}},c,i);a.sut.end(i)},f)}},setUp:function(){var a=this;this.warningHandler=function(){};this.sut=this.require("MemberBuilderValidator")(function(b){a.warningHandler(b)})},"Method cannot be both private and abstract":function(){this.quickKeywordMethodTest(["private","abstract"],"private and abstract")},"Methods cannot be declared const":function(){this.quickKeywordMethodTest(["const"],"const")},"Method cannot be both virtual and static":function(){this.quickKeywordMethodTest(["virtual",
"static"],"static")},"Cannot override getter/setter with method":function(){var a=this;this.quickFailureTest("foo","getter/setter",function(){a.sut.validateMethod("foo",function(){},{},{get:function(){}},{},{})});this.quickFailureTest("foo","getter/setter",function(){a.sut.validateMethod("foo",function(){},{},{set:function(){}},{},{})})},"Cannot override property with method":function(){var a=this;this.quickFailureTest("foo","property",function(){a.sut.validateMethod("foo",function(){},{},{member:"immaprop"},
{},{})})},"Cannot override non-virtual methods":function(){this.quickKeywordMethodTest(["override"],"non-virtual",[])},"Can override virtual method with concrete method":function(){this.quickKeywordMethodTest(["override"],null,["virtual"])},"Can declare override as virtual":function(){this.quickKeywordMethodTest(["virtual","override"])},"Cannot override concrete method with abstract method":function(){this.quickKeywordMethodTest(["abstract"],"concrete",[])},"Concrete method may appear with weak abstract method":function(){this.quickKeywordMethodTest(["weak",
"abstract"],null,[])},"Override parameter list must match or exceed parent length":function(){var a=this;this.quickFailureTest("foo","compatible",function(){a.sut.validateMethod("foo",function(){},{override:!0},{member:function(a,b,d){return[a,b,d]}},{virtual:!0},{})});this.quickFailureTest("foo","compatible",function(){var b=function(){};b.__length=3;a.sut.validateMethod("foo",function(){},{override:!0},{member:b},{virtual:!0},{})});this.assertDoesNotThrow(function(){var b=function(){};b.__length=
3;a.sut.validateMethod("foo",b,{override:!0},{member:function(){}},{virtual:!0},{})},Error)},"Weak abstract overrides must meet compatibility requirements":function(){var a=this,b=a.util.createAbstractMethod(["one"]);this.quickFailureTest("foo","compatible",function(){a.sut.validateMethod("foo",function(){},{},{member:b},{weak:!0,"abstract":!0},{})});this.quickFailureTest("foo","compatible",function(){a.sut.validateMethod("foo",b,{weak:!0,"abstract":!0},{member:function(){}},{},{})})},"Methods do not support visibiliy de-escalation":function(){this.quickVisChangeTest("public",
"protected",!0);this.quickVisChangeTest("protected","private",!0)},"Methods support visibility escalation or equality":function(){var a=this;b.visEscalationTest(function(b){a.quickVisChangeTest(b[0],b[1],!1)})},'Must provide "override" keyword when overriding methods':function(){this.quickKeywordMethodTest([],"override",[])},"Can provide abstract method impl. without override keyword":function(){this.quickKeywordMethodTest([],null,["abstract"])},"Throws warning when using override with no super method":function(){var a=
null;this.warningHandler=function(b){a=b};this.quickKeywordMethodTest(["override"]);this.assertNotEqual(null,a,"No warning was provided");this.assertOk(a instanceof Error,"Provided warning is not of type Error");this.assertOk(-1<a.message.search(b.testName),"Override warning should contain method name")},"Does not throw warning when overriding a later weak method":function(){var a=this;this.warningHandler=function(){a.fail(!0,!1,"Warning was issued.")};this.assertDoesNotThrow(function(){var b={};
a.sut.validateMethod("foo",function(){},{override:!0},void 0,void 0,b);a.sut.validateMethod("foo",function(){},{weak:!0,"abstract":!0},{member:function(){}},{override:!0},b);a.sut.end(b)})},"Cannot redeclare private members in subtypes":function(){var a=this;b.privateNamingConflictTest(function(b){a.quickVisChangeTest(b[0],b[1],!0,"conflict")})},"`proxy' keyword must provide string value":function(){var a=this;this.quickFailureTest("foo","string value expected",function(){a.sut.validateMethod("foo",
function(){},{proxy:!0},{},{},{})})},"`proxy' keyword can provide string value":function(){var a=this;this.assertDoesNotThrow(function(){a.sut.validateMethod("foo","dest",{proxy:!0},{},{},{})},TypeError)},"Method proxy cannot be abstract":function(){this.quickKeywordMethodTest(["proxy","abstract"],"cannot be abstract")}})})(g["test/MemberBuilderValidator/MethodTest"]={},"test/MemberBuilderValidator");(function(c,a){c.exports={};j=".";document.write("test/MemberBuilderValidator/PropertyTest...<br />");
var b=f(a+"/inc-common");f("common").testCase({caseSetUp:function(){var a=this;this.quickFailureTest=function(){b.quickFailureTest.apply(a,arguments)};this.quickKeywordPropTest=function(a,d,c){b.quickKeywordTest.call(this,"validateProperty",a,d,c)};this.quickVisChangeTest=function(c,i,f,g){b.quickVisChangeTest.call(a,c,i,f,function(b,c,e){a.sut.validateProperty(b,"bar",e,{member:"foo"},c)},g)}},setUp:function(){this.sut=this.require("MemberBuilderValidator")()},"Cannot override method with property":function(){var a=
this;this.quickFailureTest("foo","property",function(){a.sut.validateProperty("foo","bar",{},{member:function(){}},{})})},"Cannot declare abstract property":function(){this.quickKeywordPropTest(["abstract"],"abstract")},"Cannot declare virtual property":function(){this.quickKeywordPropTest(["virtual"],"virtual")},"Cannot declare static const property":function(){this.quickKeywordPropTest(["static","const"],"Static")},"Cannot override getter/setter with property":function(){var a=this;this.quickFailureTest("foo",
"getter/setter",function(){a.sut.validateProperty("foo","bar",{},{get:function(){}},{})});this.quickFailureTest("foo","getter/setter",function(){a.sut.validateProperty("foo","bar",{},{set:function(){}},{})})},"Properties do not support visibility de-escalation":function(){this.quickVisChangeTest("public","protected",!0);this.quickVisChangeTest("protected","private",!0)},"Properties do support visibility escalation and equality":function(){var a=this;b.visEscalationTest(function(b){a.quickVisChangeTest(b[0],
b[1],!1)})},"Cannot redeclare private properties in subtypes":function(){var a=this;b.privateNamingConflictTest(function(b){a.quickVisChangeTest(b[0],b[1],!0,"conflict")})}})})(g["test/MemberBuilderValidator/PropertyTest"]={},"test/MemberBuilderValidator");(function(c){c.exports={};j=".";document.write("test/MemberBuilder/VisibilityTest...<br />");var a=!f("common").require("util").definePropertyFallback();f("common").testCase({caseSetUp:function(){var b=this;this.buildStubMethod=function(a,c,i){var f=
{};f[i]=!0;b.sut.buildMethod(b.members,{},a,function(){return c},f,function(){},1,{})};this.buildStubProp=function(a,c,i){var f={};f[i]=!0;b.sut.buildProp(b.members,{},a,c,f,{})};this.buildStubGetterSetter=function(a,c,f,h){var g={};g[h]=!0;b.sut.buildGetterSetter(b.members,{},a,c,f,g,{})};this.assertOnlyIn=function(a,c){var f=!1;b.incAssertCount();for(var h in b.members)"undefined"!==typeof b.members[h][c]&&(f=!0,h!==a&&b.fail(c+" should only be accessible in: "+a));f||b.fail("Did not find '"+c+
"' in level: "+a)};this.basicVisPropTest=function(a){var c=a+"propname",f=a+"val";b.buildStubProp(c,f,a);b.assertEqual(b.members[a][c][0],f);b.assertOnlyIn(a,c,b.members)};this.basicVisMethodTest=function(a){var c=a+"methodname",f=a+"val";b.buildStubMethod(c,f,a);b.assertEqual(b.members[a][c](),f);b.assertOnlyIn(a,c,b.members)};this.basicVisGetterSetterTest=function(d){if(a){var c=d+"getsetname",f=function(){return!0},h=function(){};b.buildStubGetterSetter(c,f,h,d,"get");var g=Object.getOwnPropertyDescriptor(b.members[d],
c);b.assertEqual(g.get,f);b.assertEqual(g.set,h);b.assertOnlyIn(d,c,b.members)}};this.multiVisFailureTest=function(a){for(var c=[{"public":!0,"protected":!0},{"public":!0,"private":!0},{"protected":!0,"private":!0}],f=0,h=c.length;f<h;f++){b.incAssertCount();try{a("foo",c[f])}catch(g){b.assertOk(-1<g.message.search("access modifier"),"Unexpected error for multiple access modifiers");b.assertOk(-1<g.message.search("foo"),"Multiple access modifier error message should contain name of member; received: "+
g.message);break}b.fail("Should fail with multiple access modifiers: "+f)}}},setUp:function(){var a=this.require("MethodWrapperFactory")(function(a){return a});this.sut=this.require("MemberBuilder")(a,a,a,this.getMock("MemberBuilderValidator"));this.members=this.sut.initMembers()},"Can create empty member object":function(){for(var a=this.sut.initMembers(),d=["public","protected","private"],c=0,f=d.length;c<f;c++)this.assertOk("undefined"!==typeof a[d[c]],"Clean member object is missing visibility level: "+
d[c])},"Can initialize member object with existing objects":function(){var a={foo:"bar"},d={bar:"baz"},c={baz:"foo"},f=this.sut.initMembers(a,d,c),a={"public":a,"protected":d,"private":c},h;for(h in a)this.assertStrictEqual(a[h],f[h],"Visibility level '"+h+"' cannot be initialized")},"Members are only accessible via their respective interfaces":function(){var a=["public","protected","private"],d;for(d in a)this.basicVisPropTest(a[d]),this.basicVisMethodTest(a[d]),this.basicVisGetterSetterTest(a[d])},
"Members will be declared public if access modifier is omitted":function(){var b=function(){},d=function(){},c=function(){};this.sut.buildProp(this.members,{},"prop","foo",{},{});this.sut.buildMethod(this.members,{},"method",b,{},function(){},1,{});a&&this.sut.buildGetterSetter(this.members,{},"getset",d,c,{},{});this.assertStrictEqual(this.members["public"].prop[0],"foo","Properties should be public by default");this.assertStrictEqual(this.members["public"].method,b,"Methods should be public by default");
a&&(b=Object.getOwnPropertyDescriptor(this.members["public"],"getset"),this.assertStrictEqual(b.get,d,"Getters should be public by default"),this.assertStrictEqual(b.set,c,"Setters should be public by default"))},"Only one access modifier may be used per property":function(){var a=this;this.multiVisFailureTest(function(d,c){a.sut.buildProp(a.members,{},d,"baz",c,{})})},"Only one access modifier may be used per method":function(){var a=this;this.multiVisFailureTest(function(d,c){a.sut.buildMethod(a.members,
{},d,function(){},c,{})})},"Only one access modifier may be used per getter/setter":function(){if(a){var b=this;this.multiVisFailureTest(function(a,c){b.sut.buildGetterSetter(b.members,{},a,function(){},function(){},c,{})})}}})})(g["test/MemberBuilder/VisibilityTest"]={},"test/MemberBuilder");(function(c){c.exports={};j=".";document.write("test/MethodWrapperFactoryTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=this.require("MethodWrapperFactory")},"Can instantiate with and without new keyword":function(){this.assertOk(new this.Sut instanceof
this.Sut,"Should be able to instantiate MethodWrapperFactory with 'new' keyword");this.assertOk(this.Sut()instanceof this.Sut,"Should be able to instantiate MethodWrapperFactory without 'new' keyword")},"Provided factory function is properly called":function(){var a=this,b=!1,d=function(){},c=function(){},f=function(){},h={"static":!0,"public":!0},g=this.Sut(function(g,j,k,l,p,q){b=!0;a.assertEqual(g,d,"Factory method should be provided with method to wrap");a.assertEqual(j,c,"Factory method should be provided with super method");
a.assertEqual(k,55,"Factory method should be provided with cid");a.assertEqual(l,f,"Factory method should be provided with proper inst function");a.assertEqual(p,"someMethod","Factory method should be provided with proper method name");a.assertEqual(q,h,"Factory method should be provided with proper keywords");return"foobar"}).wrapMethod(d,c,55,f,"someMethod",h);this.assertEqual(b,!0,"Given factory method should be called");this.assertEqual(g,"foobar","Should return value from factory function")}})})(g["test/MethodWrapperFactoryTest"]=
{},"test");(function(c){c.exports={};j=".";document.write("test/MethodWrappersTest...<br />");f("common").testCase({caseSetUp:function(){this.proxyErrorAssertCommon=function(a,b,d){this.assertOk(-1<a.message.search("Unable to proxy"),"Unexpected error received: "+a.message);this.assertOk(-1<a.message.search(b)&&-1<a.message.search(d),"Error should contain property and method names")}},setUp:function(){this._sut=this.require("MethodWrappers")},"Method invocation binds `this` to passed instance":function(){var a=
function(){},b=function(){return a},d=this._sut.standard.wrapNew(function(){return this.foo},null,0,b),b=this._sut.standard.wrapOverride(function(){return this.foo2},d,0,b);a.foo="fooboo";a.foo2="fooboo2";this.assertEqual(d(),"fooboo","Calling method will bind 'this' to passed instance");this.assertEqual(b(),"fooboo2","Calling method override will bind 'this' to passed instance")},"Overriden method should contain reference to super method":function(){var a=this,b=!1,d=function(){};this._sut.standard.wrapOverride(function(){a.assertNotEqual(this.__super,
void 0,"__super is defined for overridden method");this.__super();a.assertEqual(b,!0,"Invoking __super calls super method")},this._sut.standard.wrapNew(function(){b=!0},null,0,d),0,d)()},"Super method works properly when context differs":function(){var a=!1,b={},d=function(){return b};this._sut.standard.wrapOverride(function(){this.__super()},this._sut.standard.wrapNew(function(){a=!0},null,0,d),0,d)();this.assertEqual(a,!0,"__super() method is called even when context differs");this.assertEqual(b.__super,
void 0,"__super() method is unset after being called")},"Can invoke super method by calling override.super":function(){var a={},b=function(){return{}};this.assertStrictEqual(this._sut.standard.wrapOverride(function(){},this._sut.standard.wrapNew(function(){return a},null,0,b),0,b)["super"](),a)},"Proxy will properly forward calls to destination object":function(){var a=[1,{},"three"],b=[],d={},c={dest:{someMethod:function(){b=Array.prototype.slice.call(arguments);return d}}},f=this._sut.standard.wrapProxy("dest",
null,0,function(){return c},"someMethod");this.assertStrictEqual(d,f.apply(c,a),"Proxy call should return the value from the destination");this.assertDeepEqual(a,b,"All arguments should be properly forwarded to the destination")},"Proxy retval is replaced with context if dest returns self":function(){var a={bar:function(){return a}},b={foo:a},d=this._sut.standard.wrapProxy("foo",null,0,function(){return b},"bar").call(b);this.assertStrictEqual(b,d,"Proxy should return instance in place of destination, if returned")},
"Proxy throws error if call will faill due to non-object":function(){try{this._sut.standard.wrapProxy("noexist",null,0,function(){return{}},"foo")()}catch(a){this.proxyErrorAssertCommon(a,"noexist","foo");return}this.assertFail("Error should be thrown if proxy would fail due to a non-object")},"Proxy throws error if call will fail due to non-function":function(){try{this._sut.standard.wrapProxy("dest",null,0,function(){return{dest:{foo:"notafunc"}}},"foo")()}catch(a){this.proxyErrorAssertCommon(a,
"dest","foo");return}this.assertFail("Error should be thrown if proxy would fail due to a non-function")},"Can proxy to static members":function(){var a=["value"],b={foo:{method:function(){return a}}};this.assertStrictEqual(a,this._sut.standard.wrapProxy("foo",null,0,function(){return{$:function(a){return b[a]}}},"method",{"static":!0})(),"Should properly proxy to static membesr via static accessor method")},"Proxy methods are able to satisfy abstract method param requirements":function(){this.assertOk(!(0<
this._sut.standard.wrapProxy({},null,0,function(){},"",{}).__length))}})})(g["test/MethodWrappersTest"]={},"test");(function(c){c.exports={};j=".";document.write("test/PropParserKeywordsTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=this.require("prop_parser")},setUp:function(){this.ptest=this.Sut.parseKeywords("virtual static abstract foo")},"Retrieves field name void of keywords":function(){this.assertEqual(this.ptest.name,"foo")},"Retrieves all keywords":function(){var a=this.ptest.keywords;
this.assertOk(a.virtual);this.assertOk(a["static"]);this.assertOk(a["abstract"])},"Does not include keywords not explicitly provided":function(){var a=this.ptest.keywords;delete a.virtual;delete a["static"];delete a["abstract"];for(var b in a)this.assertFail("Someone has been drinking: "+b);this.assertOk(!0)},"Accepts all valid keywords":function(){var a=this.Sut.parseKeywords;this.assertDoesNotThrow(function(){a("public protected private virtual abstract override static const proxy weak var")},Error)},
"Does not accept unknown keywords":function(){var a=this.Sut.parseKeywords;try{a("foobunny moobunny")}catch(b){this.assertOk(-1!==b.message.search("foobunny"),"Error message contains unrecognized keyword");this.assertOk(-1!==b.message.search("moobunny"),"Error message contains name");return}this.assertFail("Should not permit unknown keywords")},"Implciity marks underscore-prefixed members as private":function(){this.assertDeepEqual(this.Sut.parseKeywords("_foo").keywords,{"private":!0})},"Fields are not implicitly private with explicit access modifier":function(){this.assertDeepEqual(this.Sut.parseKeywords("public _foo").keywords,
{"public":!0});this.assertDeepEqual(this.Sut.parseKeywords("protected _foo").keywords,{"protected":!0});this.assertDeepEqual(this.Sut.parseKeywords("private _foo").keywords,{"private":!0})},"Double-underscore members are not implicitly private":function(){this.assertDeepEqual(this.Sut.parseKeywords("__foo").keywords,{})},"Exposes keyword bit values and masks":function(){this.assertOk(this.Sut.kvals);this.assertOk(this.Sut.kmasks)},"Access modifier bitmask catches all access modifiers":function(){var a=
this.Sut.kvals;this.assertEqual(this.Sut.kmasks.amods|a["public"]|a["protected"]|a["private"],this.Sut.kmasks.amods)},"Virtual bitmask catches abstract and virtual keywords":function(){var a=this.Sut.kvals;this.assertEqual(this.Sut.kmasks.virtual|a["abstract"]|a.virtual,this.Sut.kmasks.virtual)}})})(g["test/PropParserKeywordsTest"]={},"test");(function(c){c.exports={};j=".";document.write("test/Trait/AbstractTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=this.require("Trait");
this.Class=this.require("class");this.AbstractClass=this.require("class_abstract")},"Abstract traits create abstract classes when used":function(){var a=this.Sut({"abstract foo":[]}),b=this;this.assertDoesNotThrow(function(){b.AbstractClass.use(a).extend({})},Error)},"Concrete classes may use abstract traits by definining members":function(){var a=this.Sut({"abstract traitfoo":["foo"]}),b=null,d=!1,c=this;this.assertDoesNotThrow(function(){b=c.Class.use(a).extend({traitfoo:function(){d=!0}})});b().traitfoo();
this.assertOk(d)},"Concrete classes must be compatible with abstract traits":function(){var a=this.Sut({"abstract traitfoo":["foo"]}),b=this;this.assertThrows(function(){C=b.Class.use(a).extend({traitfoo:function(){}})})},"Traits can invoke concrete class implementation of abstract method":function(){this.assertEqual(this.Class.use(this.Sut({"public getFoo":function(){return this.echo("foobar")},"abstract protected echo":["value"]})).extend({"protected echo":function(a){return a}})().getFoo(),"foobar")},
"Traits can invoke concrete trait implementation of abstract method":function(){var a=this.Sut({"public getFoo":function(){return this.echo("traitbar")},"abstract public echo":["value"]}),b=this.Sut({"public echo":function(a){return a}});this.assertEqual(this.Class.use(a,b).extend({})().getFoo(),"traitbar");this.assertEqual(this.Class.use(b,a).extend({})().getFoo(),"traitbar","Crap; order matters?!")},"Abstract method inherited from trait can be implemented by subtype":function(){var a=!1;this.AbstractClass.use(this.Sut({"public doFoo":function(){this.foo()},
"abstract protected foo":[]})).extend({}).extend({"protected foo":function(){a=!0}})().doFoo();this.assertOk(a)},"Chained mixins properly carry abstract flag":function(){var a=this,b=this.Sut({foo:function(){}}),d=this.Sut({baz:function(){}}),c=this.Sut({"abstract baz":[]});this.assertDoesNotThrow(function(){a.assertOk(a.AbstractClass.use(c).extend({}).isAbstract());a.assertOk(a.AbstractClass.use(b).extend({"abstract baz":[]}).isAbstract());a.assertOk(a.AbstractClass.use(b).use(c).extend({}).isAbstract());
a.assertOk(a.AbstractClass.use(c).use(b).extend({}).isAbstract())});this.assertThrows(function(){a.AbstractClass.use(d).extend({})});this.assertThrows(function(){a.AbstractClass.use(c).extend({baz:function(){}})});this.assertThrows(function(){a.AbstractClass.use(c).use(d).extend({})})},"Explicitly-declared class will not be automatically abstract":function(){var a=this,b=this.Sut({foo:function(){}}),d=this.Sut({"abstract foo":[]});this.assertThrows(function(){a.assertOk(!a.AbstractClass.use(b).extend({}).isAbstract())});
this.assertDoesNotThrow(function(){a.assertOk(a.AbstractClass.use(b).extend({"abstract bar":[]}).isAbstract());a.assertOk(a.AbstractClass.use(d).extend({}).isAbstract())});this.assertThrows(function(){a.Class.use(b).extend({"abstract bar":[]})});this.assertThrows(function(){a.Class.use(d).extend()})}})})(g["test/Trait/AbstractTest"]={},"test/Trait");(function(c){c.exports={};j=".";document.write("test/Trait/ClassVirtualTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=this.require("Trait");
this.Class=this.require("class");this.AbstractClass=this.require("class_abstract");this.Interface=this.require("interface")},"Traits may implement an interface":function(){var a=this;this.assertDoesNotThrow(function(){a.Sut.implement(a.Interface({})).extend({})})},"Traits implementing interfaces define abstract methods":function(){var a=this.Sut.implement(this.Interface({foo:[],bar:[]})).extend({}),b=this.Class,d=this.AbstractClass;this.assertThrows(function(){b.use(a).extend({})});this.assertDoesNotThrow(function(){d.use(a).extend({})});
this.assertDoesNotThrow(function(){d.use(a).extend({foo:function(){}})});this.assertDoesNotThrow(function(){b.use(a).extend({foo:function(){},bar:function(){}})})},"Traits may provide concrete methods for interfaces":function(){var a=!1,b=this.Sut.implement(this.Interface({foo:[]})).extend({foo:function(){a=!0}}),d=this.Class;this.assertDoesNotThrow(function(){d.use(b).extend({})().foo()});this.assertOk(a)},"Instance of class mixing in trait implementing I is of type I":function(){var a=this.Interface({}),
b=this.Sut.implement(a).extend({});this.assertOk(this.Class.isA(a,this.Class.use(b).extend({})()))},"Trait can implement multiple interfaces":function(){var a=this.Interface({}),b=this.Interface({}),d=this.Class.use(this.Sut.implement(a,b).extend({})).extend({})();this.assertOk(this.Class.isA(a,d));this.assertOk(this.Class.isA(b,d))},"Mixin can override virtual concrete method defined by interface":function(){var a=!1,b=this.Interface({foo:[]}),d=this.Sut.implement(b).extend({"abstract override foo":function(){a=
!0}}),c=this;this.Class.implement(b).extend({"virtual foo":function(){c.fail(!1,!0,"Concrete class method was not overridden by mixin")}}).use(d)().foo();this.assertOk(a)},"Subtype must meet compatibility requirements of virtual trait method":function(){var a=this.Class.use(this.Sut({"virtual foo":function(){}}));this.assertThrows(function(){a.extend({"override foo":function(){}})()});this.assertDoesNotThrow(function(){a.extend({"override foo":function(){}})()})}})})(g["test/Trait/ClassVirtualTest"]=
{},"test/Trait");(function(c){c.exports={};j=".";document.write("test/Trait/DefinitionTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=this.require("Trait");this.Class=this.require("class");this.Interface=this.require("interface");this.AbstractClass=this.require("class_abstract");this.hasGetSet=!this.require("util").definePropertyFallback();this.ctor=[this.Sut.extend,this.Sut];this.fconflict=[["foo","same name; no keywords",{foo:function(){}},{foo:function(){}}],["foo","same keywords; same visibility",
{"public foo":function(){}},{"public foo":function(){}}],["foo","varying keywords; same visibility",{"virtual public foo":function(){}},{"public virtual foo":function(){}}],["foo","different visibility",{"public foo":function(){}},{"protected foo":function(){}}]];this.base=[this.Class]},"@each(ctor) Can extend Trait to create anonymous trait":function(a){this.assertOk(this.Sut.isTrait(a({})))},"@each(ctor) Cannot instantiate trait without error":function(a){this.assertThrows(function(){a({})()},Error)},
"@each(ctor) Base class definition is applied when using traits":function(a){a=this.Class.use(a({})).extend({foo:"bar"});this.assertOk(this.Class.isClass(a));this.assertEqual(a().foo,"bar")},"@each(ctor) Supertype definition is applied when using traits":function(a){var b=this.Class({foo:"bar"}),a=this.Class.use(a({})).extend(b,{bar:"baz"})();this.assertOk(this.Class.isA(b,a));this.assertEqual(a.foo,"bar","Supertype failure");this.assertEqual(a.bar,"baz","Subtype failure")},"@each(ctor) Trait definition is mixed into base class definition":function(a){var b=
!1,d=this.Class.use(a({foo:function(){b=!0}})).extend({})();this.assertDoesNotThrow(function(){d.foo()},Error,"Should have access to mixed in fields");this.assertOk(b,"Mixed in field copy error")},"@each(ctor) Trait definition is mixed into subtype definition":function(a){var b=!1,a=a({foo:function(){b=!0}}),d=this.Class({});this.Class.use(a).extend(d,{})().foo();this.assertOk(b)},"Traits cannot define __construct":function(){try{this.Sut({__construct:function(){}})}catch(a){this.assertOk(a.message.match(/\b__construct\b/));
return}this.fail(!1,!0,"Traits should not be able to define __construct")},"@each(fconflict) Cannot mix in multiple concrete methods of same name":function(a){var b=a[0],d=a[1],c=this.Sut(a[2]),a=this.Sut(a[3]);try{this.Class.use(c,a).extend({})}catch(f){this.assertOk(f.message.match("\\b"+b+"\\b"),"Error message missing field name: "+f.message);return}this.fail(!1,!0,"Mixin must fail on conflict: "+d)},"A class is considered to be a type of each used trait":function(){var a=this.Sut({}),b=this.Sut({}),
d=this.Sut({}),c=this.Class.use(a,b).extend({})();this.assertOk(this.Class.isA(a,c));this.assertOk(this.Class.isA(b,c));this.assertOk(!1===this.Class.isA(d,c))},"Can mix traits into named class":function(){var a=!1,b=this.Sut({foo:function(){a=!0}});this.Class("Named").use(b).extend({})().foo();this.assertOk(a)},"Explicit class definitions must be terminated by an extend call":function(){var a=this,b=this.Sut({foo:function(){}}),d=this.Sut({bar:function(){}});this.assertThrows(function(){a.Class.use(b)()},
TypeError);this.assertThrows(function(){a.Class.use(b).use(d)()},TypeError);this.assertThrows(function(){a.AbstractClass.use(b)()},TypeError);this.assertDoesNotThrow(function(){a.Class.use(b).extend({})();a.Class.use(b).use(d).extend({})()})},"Can mix traits into class after implementing interface":function(){var a=this,b=!1,d=this.Sut({foo:function(){b=!0}}),c=this.Interface({bar:[]}),f=null;this.assertDoesNotThrow(function(){f=a.AbstractClass.implement(c).use(d).extend({});a.assertOk(f.isAbstract())});
this.assertThrows(function(){a.Class.implement(c).use(d).extend({})});f.extend({bar:function(){}})().foo();this.assertOk(b)},"Trait method that returns self will return containing class":function(){var a=this;this.Class.use(this.Sut({foo:function(){return this}})).extend({go:function(){a.assertStrictEqual(this,this.foo())}})().go()},"Trait static members are prohibited":function(){var a=this.Sut;this.assertThrows(function(){a({"static private foo":"prop"})});this.assertThrows(function(){a({"static foo":function(){}})})},
"Trait getters and setters are prohibited":function(){if(this.hasGetSet){var a=this.Sut;this.assertThrows(function(){var b={};Object.defineProperty(b,"foo",{get:function(){},set:function(){},enumerable:!0});a(b)})}}})})(g["test/Trait/DefinitionTest"]={},"test/Trait");(function(c){c.exports={};j=".";document.write("test/Trait/ImmediateTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=this.require("Trait");this.Class=this.require("class")},"Invoking partial class after mixin instantiates":function(){var a=
!1,b=this.Sut({"public foo":function(){a=!0}});this.Class.extend({}).use(b)().foo();this.assertOk(a)},"Can invoke partial mixin atop of non-empty base":function(){var a=!1,b=!1,d=this.Class({"public foo":function(){a=!0}}),c=this.Sut({"public bar":function(){b=!0}}),d=d.use(c)();d.foo();d.bar();this.assertOk(a);this.assertOk(b)},"Partial arguments are passed to class constructor":function(){var a=null,b={foo:"bar"},d=this.Class({__construct:function(){a=arguments}}),c=this.Sut({});d.use(c)(b);this.assertStrictEqual(a[0],
b)}})})(g["test/Trait/ImmediateTest"]={},"test/Trait");(function(c){c.exports={};j=".";document.write("test/Trait/LinearizationTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=this.require("Trait");this.Class=this.require("class");this.Interface=this.require("interface")},"Class super call refers to mixin that is part of a class definition":function(){var a=this,b=!1;this.Class.use(this.Sut({"virtual public foo":function(){b=!0}})).extend({"override public foo":function(){try{this.__super()}catch(b){a.fail(!1,
!0,"Super invocation failure: "+b.message)}}})().foo();this.assertOk(b)},"Mixin overriding class method has class method as super method":function(){var a=this,b={},d=this.Interface({foo:[]}),c=this.Sut.implement(d).extend({"abstract override foo":function(){return this.__super(b)}}),f=Math.random();this.assertStrictEqual(this.Class.implement(d).extend({"private _priv":f,"virtual foo":function(b){a.assertEqual(f,this._priv);return b}}).use(c)().foo(),b)},"Mixin overriding another mixin method M has super method M":function(){var a,
b,d,c=this.Interface({foo:[]}),f=this.Sut.implement(c).extend({"virtual abstract override foo":function(){a=!0;this.__super()}}),g=this.Sut.implement(c).extend({"abstract override foo":function(){b=!0;this.__super()}});this.Class.implement(c).extend({"virtual foo":function(){d=!0}}).use(f).use(g)().foo();this.assertOk(a);this.assertOk(b);this.assertOk(d)},"Mixin can be mixed in atop of itself":function(){var a=0,b=!1,d=this.Interface({foo:[]}),c=this.Sut.implement(d).extend({"virtual abstract override foo":function(){a++;
this.__super()}});this.Class.implement(d).extend({"virtual foo":function(){b=!0}}).use(c).use(c).use(c)().foo();this.assertEqual(a,3);this.assertOk(b)}})})(g["test/Trait/LinearizationTest"]={},"test/Trait");(function(c){c.exports={};j=".";document.write("test/Trait/MixedExtendTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=this.require("Trait");this.Class=this.require("class")},"Subtype instantiates traits of supertype":function(){var a=!1;this.Class.use(this.Sut({foo:function(){a=
!0}})).extend({}).extend({__construct:function(){}})().foo();this.assertOk(a)},"Subtype has same polymorphic qualities of parent mixins":function(){var a=this.Sut({}),b=this.Class.use(a).extend({}).extend({})();this.assertOk(this.Class.isA(a,b))},"Subtype can mix in additional traits":function(){var a=!1,b=!1,d=this.Sut({"public ta":function(){a=!0}}),c=this.Sut({"public tb":function(){b=!0}}),f=null,g=this;this.assertDoesNotThrow(function(){var a=g.Class.use(d).extend({});f=g.Class.use(c).extend(a,
{})});this.assertDoesNotThrow(function(){var a=f();a.ta();a.tb()});this.assertOk(a);this.assertOk(b)},"Subtype trait types do not overwrite supertype types":function(){var a=this.Sut({}),b=this.Sut({}),d=this.Class.use(a).extend({}),d=this.Class.use(b).extend(d,{})();this.assertOk(this.Class.isA(a,d));this.assertOk(this.Class.isA(b,d))},"Can mix in traits directly atop of existing class":function(){var a=!1,b=!1,d=!1,c=this.Class({"public foo":function(){a=!0}}),f=this.Sut({"public bar":function(){b=
!0}}),c=c.use(f).extend({"public baz":function(){d=!0}})();c.foo();c.bar();c.baz();this.assertOk(a);this.assertOk(b);this.assertOk(d)},"Can chain use calls":function(){var a=this.Sut({foo:function(){}}),b=this.Sut({bar:function(){}}),d=null,c=this.Class;this.assertDoesNotThrow(function(){d=c.extend({}).use(a).use(b)});this.assertDoesNotThrow(function(){d().foo();d().bar()})}})})(g["test/Trait/MixedExtendTest"]={},"test/Trait");(function(c){c.exports={};j=".";document.write("test/Trait/NamedTest...<br />");
f("common").testCase({caseSetUp:function(){this.Sut=this.require("Trait");this.Class=this.require("class");this.Interface=this.require("interface")},"Anonymous trait is properly indicated when converted to string":function(){this.assertEqual(this.Sut({}).toString(),"(Trait)")},"Named trait contains name when converted to string":function(){this.assertOk(this.Sut("FooTrait",{}).toString().match("FooTrait"))},"Named trait definition cannot contain zero or more than two arguments":function(){var a=this.Sut;
this.assertThrows(function(){a()});this.assertThrows(function(){a(1,2,3)})},"First argument in named trait definition must be a string":function(){var a=this.Sut;this.assertThrows(function(){a({},{})})},"Providing only trait name creates staging object":function(){var a=this.Sut;this.assertDoesNotThrow(function(){a("Foo")})},"Can extend named trait staging object":function(){var a=this.Sut,b={},d=null;this.assertDoesNotThrow(function(){d=a("Foo").extend({foo:function(){return b}})});this.assertStrictEqual(this.Class({}).use(d)().foo(),
b);this.assertOk(d.toString().match("Foo"))},"Can implement interface using named trait staging object":function(){var a=this.Sut,b=this.Interface({}),d=this.Interface({}),c=null;this.assertDoesNotThrow(function(){c=a("Foo").implement(b,d).extend({})});var f=this.Class({}).use(c)();this.assertOk(this.Class.isA(b,f));this.assertOk(this.Class.isA(d,f));this.assertOk(c.toString().match("Foo"))}})})(g["test/Trait/NamedTest"]={},"test/Trait");(function(c){c.exports={};j=".";document.write("test/Trait/ParameterTest...<br />");
f("common").testCase({caseSetUp:function(){this.Sut=this.require("Trait");this.Class=this.require("class");var a=this;this.createParamTrait=function(b){return a.Sut({__mixin:b||function(){}})}},"Can create parameter traits":function(){var a=this.createParamTrait();this.assertOk(this.Sut.isParameterTrait(a));this.assertOk(this.Sut.isTrait(a))},"Cannot mix in a parameter trait":function(){var a=this;this.assertThrows(function(){a.Class.use(a.createParamTrait())()})},"Invoking parameter trait produces argument trait":function(){var a=
this;this.assertDoesNotThrow(function(){a.assertOk(a.Sut.isArgumentTrait(a.createParamTrait()()))})},"Invoking a standard trait throws an exception":function(){var a=this.Sut;this.assertThrows(function(){a({})()})},"Recognizes argument trait as a trait":function(){this.assertOk(this.Sut.isTrait(this.createParamTrait()()))},"Cannot re-configure argument trait":function(){var a=this;this.assertThrows(function(){a.createParamTrait()()()})},"__mixin is invoked upon class instantiation":function(){var a=
0,b=this.createParamTrait(function(){a++});this.Class({}).use(b())();this.assertEqual(a,1)},"__mixin is passed arguments by reference":function(){var a,b={a:"a"},d={b:"b"},c=this.createParamTrait(function(){a=arguments});this.Class({}).use(c(b,d))();this.assertStrictEqual(b,a[0]);this.assertStrictEqual(d,a[1])},"__mixin has access to trait private members":function(){var a={},b=this.Sut({"private _foo":null,__mixin:function(a){this._foo=a},getFoo:function(){return this._foo}});this.assertStrictEqual(a,
this.Class({}).use(b(a))().getFoo())},"__mixin with empty parameter list is still invoked":function(){var a={},b,d=this.createParamTrait(function(){b=a});this.Class({}).use(d())();this.assertStrictEqual(a,b)},"Mixing in param trait will invoke __mixin with no arguments":function(){var a=0,b=this.createParamTrait(function(){a|=1}),d=this.createParamTrait(function(){a|=2}),c=this.Class({});this.assertDoesNotThrow(function(){c.use(b)();c.use(d)()});this.assertEqual(a,3)},"Invokes __mixin of each sibling mixin":function(){var a=
[],b=[{},[]],d=function(){a.push(arguments)},c=this.createParamTrait(d),d=this.createParamTrait(d);this.Class({}).use(c(b[0]),d(b[1]))();this.assertEqual(a.length,2);this.assertStrictEqual(a[0][0],b[0]);this.assertStrictEqual(a[1][0],b[1])},"Invokes __mixin before __construct when C.use(T)":function(){var a=!1,b=this.createParamTrait(function(){a=!0}),d=this.Class({__construct:function(){if(!a)throw Error("__construct called before __mixin");}});this.assertDoesNotThrow(function(){d.use(b)()})},"Invokes __construct before __mixin when Class.use(T).extend()":function(){var a=
!1,b=this.Class.use(this.createParamTrait(function(){if(!a)throw Error("__mixin called before __construct");})).extend({__construct:function(){a=!0}});this.assertDoesNotThrow(function(){b()})},"Subtype invokes ctor before supertype __construct or __mixin":function(){var a=!1,b=this.createParamTrait(function(){if(!a)throw Error("__mixin called before Sub#__construct");}),d=this.Class({}).use(b).extend({__construct:function(){a=!0}});this.assertDoesNotThrow(function(){d()})}})})(g["test/Trait/ParameterTest"]=
{},"test/Trait");(function(c){c.exports={};j=".";document.write("test/Trait/PropertyTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=this.require("Trait")},"Private trait properties are permitted":function(){var a=this.Sut;this.assertDoesNotThrow(function(){a({"private _foo":"bar"})})},"Public and protected trait properties are prohibited":function(){var a=this.Sut;this.assertThrows(function(){a({"public foo":"bar"})});this.assertThrows(function(){a({"protected foo":"bar"})})}})})(g["test/Trait/PropertyTest"]=
{},"test/Trait");(function(c){c.exports={};j=".";document.write("test/Trait/ScopeTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=this.require("Trait");this.Class=this.require("class")},"Private class members are not accessible to used traits":function(){var a=this.Class.use(this.Sut({"public getPriv":function(){return this._priv},"public invokePriv":function(){this._privMethod()}})).extend({"private _priv":"foo","private _privMethod":function(){}})();this.assertEqual(a.getPriv(),
void 0);this.assertThrows(function(){a.invokePriv()},Error)},"Private trait members are not accessible to containing class":function(){var a=this.Class.use(this.Sut({"private _priv":"bar","private _privMethod":function(){}})).extend({"public getPriv":function(){return this._priv},"public invokePriv":function(){this._privMethod()}})();this.assertEqual(a.getPriv(),void 0);this.assertThrows(function(){a.invokePriv()},Error)},"Traits do not have access to each others' private members":function(){var a=
this.Sut({"private _priv1":"foo","private _privMethod1":function(){}}),b=this.Sut({"public getPriv":function(){return this._priv1},"public invokePriv":function(){this._privMethod1()}}),d=this.Class.use(a,b).extend({})();this.assertEqual(d.getPriv(),void 0);this.assertThrows(function(){d.invokePriv()},Error)},"Classes can access protected trait members":function(){var a=this.Sut({"protected foo":function(){}}),b=this;this.assertDoesNotThrow(function(){b.Class.use(a).extend({"public callFoo":function(){this.foo()}})().callFoo()})}})})(g["test/Trait/ScopeTest"]=
{},"test/Trait");(function(c){c.exports={};j=".";document.write("test/Trait/VirtualTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=this.require("Trait");this.Class=this.require("class")},"Class inherits virtual trait method":function(){var a=!1,b=this.Class.use(this.Sut({"virtual foo":function(){a=!0}})).extend({});b().foo();this.assertOk(a,"Virtual method not called");var d=!1,c;this.assertDoesNotThrow(function(){c=b.extend({"override foo":function(){d=!0}})});c().foo();this.assertOk(d,
"Method not overridden")},"Class can override virtual trait method":function(){var a=this;this.assertEqual(this.Class.use(this.Sut({"virtual foo":function(){a.fail(!0,!1,"Method was not overridden.")}})).extend({"override foo":function(){return"foobar"}})().foo(),"foobar")},"Class-overridden virtual trait method is accessible by trait":function(){var a=this,b=!1;this.Class.use(this.Sut({"public doFoo":function(){this.foo()},"virtual protected foo":function(){a.fail(!0,!1,"Method not overridden.")}})).extend({"override protected foo":function(){b=
!0}})().doFoo();this.assertOk(b)},"Subtype can override virtual method of trait mixed into supertype":function(){var a=this,b=!1;this.Class.use(this.Sut({"public doFoo":function(){return this.foo()},"virtual protected foo":function(){a.fail(!0,!1,"Method not overridden.")}})).extend({}).extend({"override protected foo":function(){b=!0}})().doFoo();this.assertOk(b)},"Properly invokes non-overridden virtual trait methods":function(){var a={a:!0},b={b:!0},d=this.Class.use(this.Sut({pub:function(){return this.vpub()},
prot:function(){return this.vprot()},"virtual public vpub":function(){return a},"virtual protected vprot":function(){return b}})).extend({})();this.assertStrictEqual(d.pub(),a);this.assertStrictEqual(d.prot(),b)},"Virtual trait method returning self returns class instance":function(){var a=this;this.Class.use(this.Sut({"virtual foo":function(){return this}})).extend({go:function(){a.assertStrictEqual(this,this.foo())}})().go()},"Overridden virtual trait method returning self returns class instance":function(){var a=
this;this.Class.use(this.Sut({"virtual foo":function(){return this}})).extend({"override foo":function(){return this.__super()},go:function(){a.assertStrictEqual(this,this.foo())}})().go()},"Data are properly returned from trait override super call":function(){var a=this,b={};this.Class.use(this.Sut({"virtual foo":function(){return b}})).extend({"override foo":function(){a.assertStrictEqual(b,this.__super())}})().foo()},"Super trait method overrided in class executed within private context":function(){var a=
{},b=this.Sut({"virtual foo":function(){return this.priv()},"private priv":function(){return a}});this.assertStrictEqual(a,this.Class.use(b).extend({"override virtual foo":function(){return this.__super()}})().foo())}})})(g["test/Trait/VirtualTest"]={},"test/Trait");(function(c){c.exports={};j=".";document.write("test/Util/AbstractTest...<br />");f("common").testCase({setUp:function(){this.Sut=this.require("util")},"abstractMethod returns a function":function(){this.assertEqual(typeof this.Sut.createAbstractMethod(),
"function")},"Returned function is considered abstract by isAbstractMethod":function(){this.assertOk(this.Sut.isAbstractMethod(this.Sut.createAbstractMethod()))},"Abstract methods cannot be invoked":function(){var a=this.Sut;this.assertThrows(function(){a.createAbstractMethod()()},Error)}})})(g["test/Util/AbstractTest"]={},"test/Util");(function(c){c.exports={};j=".";document.write("test/Util/CloneTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=this.require("util")},"Cloned array is not the same object as the original":function(){var a=
[1,2,3];this.assertNotStrictEqual(this.Sut.clone(a),a)},"Cloned object is not the same object as the original":function(){var a={foo:"bar"};this.assertNotStrictEqual(this.Sut.clone(a),a)},"Cloned array data mirrors original (shallow clone)":function(){for(var a=[1,"2",{three:3},[4]],b=this.Sut.clone(a),d=0,c=a.length;d<c;d++)this.assertStrictEqual(a[d],b[d])},"Cloned object data mirrors original (shallow clone)":function(){var a={a:1,b:[2],c:{three:3},d:"4"},b=this.Sut.clone(a),d;for(d in a)this.assertStrictEqual(a[d],
b[d])},"Deeply cloned array data mirrors original":function(){var a=[[1,2],[3,4],[5,[6,7]],{a:1}],b=this.Sut.clone(a,!0);this.assertDeepEqual(a,b);for(var d=0,c=a.length;d<c;d++)this.assertNotStrictEqual(a[d],b[d])},"Deeply cloned object data mirrors original":function(){var a={a:[1],b:[2],c:{d:3}},b=this.Sut.clone(a,!0);this.assertDeepEqual(a,b);for(var d in a)this.assertNotStrictEqual(a[d],b[d])},"Functions are returned by reference, not cloned":function(){var a=function(){};this.assertStrictEqual(a,
this.Sut.clone({foo:a},!0).foo)},"Primitives are returned by clone":function(){for(var a=[null,1,!0,!1,void 0],b=a.length;b--;){var d=a[b];this.assertEqual(d,this.Sut.clone(d),"Failed to clone primitive value: "+d)}this.assertOk(isNaN(this.Sut.clone(NaN)))}})})(g["test/Util/CloneTest"]={},"test/Util");(function(c){c.exports={};j=".";document.write("test/Util/CopyTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=this.require("util");this.hasGetSet=!this.Sut.definePropertyFallback()},
"Values are copied to destination object by reference":function(){var a={a:"a",b:2,c:!0,d:!1,e:void 0,f:null,g:function(){}},b={};this.Sut.copyTo(b,a);for(var d in a)this.assertStrictEqual(a[d],b[d])},"Getters and setters are copied to destination object by reference":function(){this.hasGetSet||this.skip();var a=function(){},b=function(){},d={},c={},f=null;Object.defineProperty(d,"foo",{get:a,set:b,enumerable:!0});this.Sut.copyTo(c,d);f=Object.getOwnPropertyDescriptor(c,"foo");this.assertStrictEqual(f.get,
a,"Getter is copied by reference by default");this.assertDeepEqual(f.set,b,"Setter is copied by reference by default")},"Copy operation returns destination object":function(){var a={};this.assertStrictEqual(this.Sut.copyTo(a,{}),a)},"Throws error if source or dest are not provided":function(){var a=this.Sut.copyTo;this.assertThrows(function(){a()},TypeError,"Dest parameter is required");this.assertThrows(function(){a("bla",{})},TypeError,"Dest parameter is required to be an object");this.assertThrows(function(){a({})},
TypeError,"Src parameter is required");this.assertThrows(function(){a({},"foo")},TypeError,"Src parameter is required to be an object")},"Deep copies are supported":function(){var a={foo:[1,2,3]},b=this.Sut.copyTo({},a,!0);this.assertDeepEqual(a.val,b.val,"Copied values should be comparitively equal with deep copy");this.assertNotStrictEqual(a.foo,b.foo,"Copied values should not be the same object after deep copy")}})})(g["test/Util/CopyTest"]={},"test/Util");(function(c){c.exports={};j=".";document.write("test/Util/DefineSecurePropTest...<br />");
f("common").testCase({caseSetUp:function(){this.Sut=this.require("util");this.expected=Object.defineProperty instanceof Function?!1:!0;this.fallback=this.Sut.definePropertyFallback();if(!this.expected&&this.fallback)try{if(this.Sut.definePropertyFallback(!1),this.Sut.defineSecureProp({},"foo",1),!0===this.Sut.definePropertyFallback())this.expected=!0}catch(a){}this.descRestrictionCheck=function(a,d){this.fallback&&this.skip();var c={};this.Sut.defineSecureProp(c,"foo",null);this.assertEqual(Object.getOwnPropertyDescriptor(c,
"foo")[a],d)};this.forceFallback=function(a){this.Sut.definePropertyFallback(!0);a.call(this);this.Sut.definePropertyFallback(this.fallback)}},"definePropertyFallback returns whether secure definition is supported":function(){this.assertEqual(this.expected,this.Sut.definePropertyFallback())},"definePropertyFallback returns util when used as a setter":function(){this.assertStrictEqual(this.Sut.definePropertyFallback(this.fallback),this.Sut)},"Defining secure prop creates field with given value on given object":function(){var a=
{},b={bar:"baz"};this.Sut.defineSecureProp(a,"foo",b);this.assertStrictEqual(a.foo,b)},"Secure property is not writable":function(){this.descRestrictionCheck("writable",!1)},"Secure property is not configurable":function(){this.descRestrictionCheck("configurable",!1)},"Secure property is not enumerable":function(){this.descRestrictionCheck("enumerable",!1)},"Defining secure prop creates field and value when falling back":function(){this.forceFallback(function(){var a={},b={bar:"baz"};this.Sut.defineSecureProp(a,
"foo",b);this.assertStrictEqual(a.foo,b)})},"Secure property is writable when falling back":function(){this.forceFallback(function(){this.descRestrictionCheck("writable",!0)})},"Secure property is configurable when falling back":function(){this.forceFallback(function(){this.descRestrictionCheck("configurable",!0)})},"Secure property is enumerable when falling back":function(){this.forceFallback(function(){this.descRestrictionCheck("enumerable",!0)})}})})(g["test/Util/DefineSecurePropTest"]={},"test/Util");
(function(c){c.exports={};j=".";document.write("test/Util/GetPropertyDescriptorTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=this.require("util");this.hasGetSet=!this.Sut.definePropertyFallback()},"Should use Object.getOwnPropertyDescriptor if available":function(){(!this.hasGetSet||!Object.getOwnPropertyDescriptor)&&this.skip();this.assertStrictEqual(this.Sut.getOwnPropertyDescriptor,Object.getOwnPropertyDescriptor)},"Indicates whether property chain traversal is possible":function(){this.assertEqual(this.Sut.getPropertyDescriptor.canTraverse,
"function"===typeof Object.getPrototypeOf)},"Traversable property is non-writable":function(){(!this.hasGetSet||!Object.getOwnPropertyDescriptor)&&this.skip();this.assertEqual(Object.getOwnPropertyDescriptor(this.Sut.getPropertyDescriptor,"canTraverse").writable,!1)},"Acts as ES5 getOwnPropertyDescriptor when one level deep":function(){var a={foo:"bar"},b=this.Sut.getOwnPropertyDescriptor(a,"foo"),a=this.Sut.getPropertyDescriptor(a,"foo");this.assertDeepEqual(b,a)},"Traverses the prototype chain when necessary":function(){this.Sut.getPropertyDescriptor.canTraverse||
this.skip();var a={foo:"bar"},b=function(){};b.prototype=a;b=new b;a=this.Sut.getOwnPropertyDescriptor(a,"foo");this.assertDeepEqual(this.Sut.getPropertyDescriptor(b,"foo"),a)}})})(g["test/Util/GetPropertyDescriptorTest"]={},"test/Util");(function(c){c.exports={};j=".";document.write("test/Util/GlobalTest...<br />");var a=this;f("common").testCase({caseSetUp:function(){this.Sut=this.require("util/Global");this.gobj=this.Sut.expose();this.uniq="___$$easejs$globaltest$$"},"Global object represents environment global object":function(){switch(!0){case a.window:this.assertStrictEqual(this.gobj,
a.window);break;case a.root:this.assertStrictEqual(this.gobj,a.root);break;default:this.assertStrictEqual(this.gobj.Array,Array)}},"Providing alternative will set value if name does not exist":function(){var a=this.Sut(),d=this.uniq,c={_:"easejsOK"};a.provideAlt(d,function(){return c});this.assertStrictEqual(a.get(d),c)},"Providing alternative will not pollute the global scope":function(){this.Sut().provideAlt(this.uniq,function(){return{}});this.assertEqual(this.gobj[this.uniq],void 0)},"Providing alternative will not modify global if name exists":function(){var a=
this.Sut(),d=this.gobj.Array;a.provideAlt("Array",function(){return{}});this.assertStrictEqual(a.get("Array"),d)},"Providing alternative twice will not modify first alternative":function(){var a=this.Sut();field=this.uniq;expected={_:"easejsOK"};a.provideAlt(field,function(){return expected});a.provideAlt(field,function(){return"oops"});this.assertStrictEqual(a.get(field),expected)},"provideAlt returns self for method chaining":function(){var a=this.Sut();this.assertStrictEqual(a,a.provideAlt("foo",
function(){}))}})})(g["test/Util/GlobalTest"]={},"test/Util");(function(c){c.exports={};j=".";document.write("test/Util/PropParseKeywordsTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=this.require("util")},"`abstract' keyword designates method as abstract":function(){var a=this,b=["one","two"],d=null;this.Sut.propParse({"abstract foo":b},{method:function(c,f,g){a.assertOk(g);a.assertEqual(typeof f,"function");a.assertOk(a.Sut.isAbstractMethod(f));a.assertEqual(f.__length,b.length);
d=c}});this.assertEqual(d,"foo")},"Not considered abstract when `override' also provided":function(){var a=this,b=null;this.Sut.propParse({"abstract override foo":function(){}},{method:function(c,e,f){a.assertOk(!1===f);a.assertEqual(typeof e,"function");a.assertOk(!1===a.Sut.isAbstractMethod(e));b=c}});this.assertEqual(b,"foo")},"Supports custom property keyword parser":function(){var a={foo:{"abstract":!0}},b=[];this.Sut.propParse({foo:[]},{keywordParser:function(b){return{name:b+"poo",keywords:a[b]}},
method:function(a,c,f){f&&b.push(a)}});this.assertOk("foopoo"===b[0],"Can provide custom property keyword parser")},"Keyword parser tolerates bogus responses":function(){var a=this.Sut.propParse;this.assertDoesNotThrow(function(){var b={foo:"bar"};a(b,{keywordParser:function(){}});a(b,{keywordParser:function(){return{name:[],keywords:"slefwef"}}})},Error)},"Parser returns keywords":function(){var a={"public foo":"","const foo2":"","public private const foo3":"","public static virtual method":function(){},
"public  const   spaces":function(){}},b={},c={foo:{"public":!0},foo2:{"const":!0},foo3:{"public":!0,"private":!0,"const":!0},method:{"public":!0,"static":!0,virtual:!0},spaces:{"public":!0,"const":!0}};this.Sut.propParse(a,{property:function(a,c,d){b[a]=d},method:function(a,c,d,e){b[a]=e}});for(var e in b)this.assertDeepEqual(b[e],c[e],"Keywords are properly recognized and made available for interpretation ("+e+")");!1===this.Sut.definePropertyFallback()&&(a={},b={},Object.defineProperty(a,"public foo",
{get:function(){},set:function(){},enumerable:!0}),this.Sut.propParse(a,{getset:function(a,c,d,e){c&&(b[a+"g"]=e);d&&(b[a+"s"]=e)}}),this.assertDeepEqual(b.foog,{"public":!0},"Getter keywords are properly recognized and available"),this.assertDeepEqual(b.foos,{"public":!0},"Setter keywords are properly recognized and available"))}})})(g["test/Util/PropParseKeywordsTest"]={},"test/Util");(function(c){c.exports={};j=".";document.write("test/Util/PropParseTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=
this.require("util");this.hasGetSet=!this.Sut.definePropertyFallback();this.checkType=function(a,b,c){this.checkTypeEx("foo",{foo:a},b,c)};this.checkTypeEx=function(a,b,c,e){var a={},f=null;a[c]=function(a){a===a&&(f=arguments)};this.Sut.propParse(b,a);this.assertOk(null!==f,"Type failure");e&&e.apply(this,f)}},"Detects string as property":function(){this.checkType("string","property")},"Detects boolean as property":function(){this.checkType(!0,"property");this.checkType(!1,"property")},"Detects integer as property":function(){this.checkType(1,
"property")},"Detects float as property":function(){this.checkType(3.14159,"property")},"Detects array as property":function(){this.checkType([],"property")},"Detects object as property":function(){this.checkType({},"property")},"Detects normal functions as concrete methods":function(){this.checkType(function(){},"method",function(a,b,c){this.assertOk(!c)})},"Detects special functions as abstract methods":function(){this.checkType(this.Sut.createAbstractMethod(),"method",function(a,b,c){this.assertOk(c)})},
"Detects proxies as methods":function(){this.checkTypeEx("foo",{"proxy foo":"bar"},"method")},"Detects getters and setters":function(){this.hasGetSet||this.skip();var a={},b,c,e=!1;Object.defineProperty(a,"foo",{get:b=function(){e=!0},set:c=function(){},enumerable:!0});this.checkTypeEx("foo",a,"getset",function(a,f,g){this.assertStrictEqual(b,f,"Getter mismatch");this.assertStrictEqual(c,g,"Setter mismatch");this.assertEqual(e,!1,"Getter should not be called during processing")})},"Ignores prototype fields":function(){var a=
function(){};a.prototype.one=1;a=new a;a.two=2;var b=[];this.Sut.propParse(a,{each:function(a){b.push(a)}});this.assertEqual(b.length,1);this.assertEqual(b[0],"two")},"Triggers error if invalid variable names are used as param names":function(){var a=this.Sut.propParse;this.assertThrows(function(){a({"abstract foo":["invalid name"]},{})},SyntaxError);this.assertThrows(function(){a({"abstract foo":["1invalid"]},{})},SyntaxError);this.assertDoesNotThrow(function(){a({"abstract foo":["valid_name"]},
{})},SyntaxError)},"Supports dynamic context to handlers":function(){function a(){b.assertStrictEqual(this,c)}var b=this,c={},e={prop:"prop",method:function(){}};this.hasGetSet&&Object.defineProperty(e,"getset",{get:function(){},set:function(){},enumerable:!0});this.Sut.propParse(e,{each:a,property:a,getset:a,method:a},c)}})})(g["test/Util/PropParseTest"]={},"test/Util");(function(c){c.exports={};j=".";document.write("test/Util/symbol/FallbackSymbolTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=
this.require("util/symbol/FallbackSymbol")},"Constructor returns an instance of Symbol":function(){this.assertOk(this.Sut()instanceof this.Sut)},"Generated string varies with each call":function(){for(var a={},b=32;b--;){var c=this.Sut();a[c]&&this.fail(c,"");a[c]=!0}this.assertOk("passed")}})})(g["test/Util/symbol/FallbackSymbolTest"]={},"test/Util/symbol");(function(c){c.exports={};j=".";document.write("test/Util/SymbolTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=this.require("util/Symbol")},
"Exports a function":function(){this.assertOk("function"===typeof this.Sut)}})})(g["test/Util/SymbolTest"]={},"test/Util");(function(c){c.exports={};j=".";document.write("test/VersionTest...<br />");f("common").testCase({caseSetUp:function(){this.version=this.require("version")},"Can retrieve major version number":function(){this.assertOk("number"===typeof this.version.major,"Major version number should be available")},"Can retrieve minor version number":function(){this.assertOk("number"===typeof this.version.minor,
"Minor version number should be available")},"Can retrieve revision version number":function(){this.assertOk("number"===typeof this.version.rev,"Revision version number should be available")},"Array of version numbers is available":function(){this.assertEqual(this.version.major,this.version[0]);this.assertEqual(this.version.minor,this.version[1]);this.assertEqual(this.version.rev,this.version[2])},"Version string is available":function(){var a=this.version;this.assertEqual(a.major+"."+a.minor+"."+
a.rev+(a.suffix&&"-"+a.suffix||""),this.version.toString(),"Version string should be made available")}})})(g["test/VersionTest"]={},"test");(function(c){c.exports={};j=".";document.write("test/VisibilityObjectFactoryFactoryTest...<br />");f("common").testCase({caseSetUp:function(){this.sut=this.require("VisibilityObjectFactoryFactory");this.VisibilityObjectFactory=this.require("VisibilityObjectFactory");this.FallbackVisibilityObjectFactory=this.require("FallbackVisibilityObjectFactory");this.util=
this.require("util")},"Returns standard factory if not falling back":function(){this.util.definePropertyFallback()||this.assertOk(this.sut.fromEnvironment()instanceof this.VisibilityObjectFactory,"Creates standard VisibilityObjectFactory if supported")},"Returns fallback factory if falling back":function(){var a=this.util.definePropertyFallback();this.util.definePropertyFallback(!0);this.assertOk(this.sut.fromEnvironment()instanceof this.FallbackVisibilityObjectFactory,"Creates fallback VisibilityObjectFactory if falling back");
this.util.definePropertyFallback(a)}})})(g["test/VisibilityObjectFactoryFactoryTest"]={},"test");(function(c){c.exports={};j=".";document.write("test/VisibilityObjectFactoryTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=this.require("VisibilityObjectFactory");this.props={"public":{pub:[["foo"],{}]},"protected":{prot:[["bar"],{}]},"private":{priv:[["baz"],{}]}};this.methods={"public":{fpub:function(){var a=function(){};a.___$$keywords$$={"public":!0};return a}()},"protected":{fprot:function(){}},
"private":{fpriv:function(){}}}},setUp:function(){this.require("util").definePropertyFallback()&&this.skip();this.sut=this.Sut()},"Can instantiate with and without `new` keyword":function(){this.assertOk(new this.Sut instanceof this.Sut,"Should be able to instantiate VisibilityObjectFactory with 'new' keyword");this.assertOk(this.Sut()instanceof this.Sut,"Should be able to instantiate VisibilityObjectFactory without 'new' keyword")},"Can create property proxy":function(){var a={},b={},c={one:!0,two:!0,
three:!0};this.sut.createPropProxy(a,b,c);for(var e in c)b[e]="foo",this.assertEqual(b[e],"foo","Property can be set/retrieved on destination object"),this.assertEqual(a[e],"foo","Property can be set via proxy and retrieved on base"),a[e]="bar",this.assertEqual(b[e],"bar","Property can be set on base and retrieved on dest object")},"Setup creates private layer":function(){var a={foo:[]},b=this.sut.setup(a,this.props,this.methods);this.assertNotEqual(b,a,"Returned object should not be the destination object");
this.assertStrictEqual(b.foo,a.foo,"Destination object is part of the prototype chain of the returned obj")},"Private layer includes protected member proxy":function(){var a={};this.sut.setup(a,this.props,this.methods).prot="foo";this.assertEqual(a.prot,"foo","Protected values are proxied from private layer")},"Public properties are copied to destination object":function(){var a={};this.sut.setup(a,this.props,this.methods);this.assertEqual(a.pub[0],this.props["public"].pub[0],"Public properties are properly initialized");
this.assertNotStrictEqual(a.pub,this.props["public"].pub,"Public properties should not be copied by reference");this.assertEqual(a.fpub,void 0,"Public method references should not be copied")},"Protected properties and methods are added to dest object":function(){var a={};this.sut.setup(a,this.props,this.methods);this.assertEqual(a.prot[0],this.props["protected"].prot[0],"Protected properties are properly initialized");this.assertNotStrictEqual(a.prot,this.props["protected"].prot,"Protected properties should not be copied by reference");
this.assertStrictEqual(a.fprot,this.methods["protected"].fprot,"Protected members should be copied by reference")},"Public methods are not overwritten by default":function(){var a={fpub:this.methods["public"].fpub};this.methods["protected"].fpub=function(){};this.sut.setup(a,this.props,this.methods);this.assertStrictEqual(a.fpub,this.methods["public"].fpub,"Public methods should not be overwritten by protected methods")},"Public methods are not overwritten when keyword is omitted":function(){var a=
function(){};a.___$$keywords$$={};var b={fpub:a};this.methods["protected"].fpub=function(){};this.sut.setup(b,this.props,this.methods);this.assertStrictEqual(b.fpub,a,"Public methods should not be overwritten by protected methods")},"Private properties and methods are added to dest object":function(){var a=this.sut.setup({},this.props,this.methods);this.assertEqual(a.priv[0],this.props["private"].priv[0],"Private properties are properly initialized");this.assertNotStrictEqual(a.priv,this.props["private"].priv,
"Private properties should not be copied by reference");this.assertStrictEqual(a.fpriv,this.methods["private"].fpriv,"Private members should be copied by reference")}})})(g["test/VisibilityObjectFactoryTest"]={},"test");(function(c){c.exports={};j=".";document.write("test/warn/DismissiveHandlerTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=this.require("warn/DismissiveHandler");this.Warning=this.require("warn/Warning")},"Can be instantiated without `new` keyword":function(){this.assertOk(this.Sut()instanceof
this.Sut)},"Does nothing":function(){var a=this;this.assertDoesNotThrow(function(){a.Sut().handle(a.Warning(Error("Ignore me!")))})}})})(g["test/warn/DismissiveHandlerTest"]={},"test/warn");(function(c){c.exports={};j=".";document.write("test/warn/LogHandlerTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=this.require("warn/LogHandler");this.Warning=this.require("warn/Warning")},setUp:function(){this.stubwarn=this.Warning(Error("gninraw"))},"Can be instantiated without `new` keyword":function(){this.assertOk(this.Sut()instanceof
this.Sut)},"Logs messages to console":function(){var a=this,b=!1;this.Sut({warn:function(c){a.assertEqual("Warning: "+a.stubwarn.message,c);b=!0}}).handle(this.stubwarn);this.assertOk(b,!0,"Message should be logged to console")},"Ignores missing console":function(){var a=this;this.assertDoesNotThrow(function(){a.Sut(void 0).handle(a.warnstub)})},"Falls back to log if warn is missing":function(){var a="";this.Sut({log:function(b){a=b}}).handle(this.stubwarn);this.assertEqual("Warning: "+this.stubwarn.message,
a,"Should fall back to log() and log proper message")},"`warn` takes precedence over `log`":function(){var a=warn=!1;this.Sut({warn:function(){warn=!0},log:function(){a=!0}}).handle(this.stubwarn);this.assertOk(warn);this.assertOk(!a)}})})(g["test/warn/LogHandlerTest"]={},"test/warn");(function(c){c.exports={};j=".";document.write("test/warn/ThrowHandlerTest...<br />");f("common").testCase({caseSetUp:function(){this.Sut=this.require("warn/ThrowHandler");this.Warning=this.require("warn/Warning")},
"Can be instantiated without `new` keyword":function(){this.assertOk(this.Sut()instanceof this.Sut)},"`throwError' warning handler throws wrapped error":function(){var a=this.Warning(Error("gninraw"));try{this.Sut().handle(a)}catch(b){this.assertStrictEqual(b,a.getError(),"Wrapped exception should be thrown");return}this.assertFail("Wrapped exception should be thrown")}})})(g["test/warn/ThrowHandlerTest"]={},"test/warn");(function(c){c.exports={};j=".";document.write("test/warn/WarningTest...<br />");
f("common").testCase({caseSetUp:function(){this.Sut=this.require("warn").Warning},"Warning has Error prototype":function(){this.assertOk(new this.Sut(Error())instanceof Error)},"Warning should alter Error name":function(){this.assertEqual(this.Sut(Error()).name,"Warning")},"`new' operator is not necessary to instantiate Warning":function(){this.assertOk(this.Sut(Error(""))instanceof this.Sut)},"Warning message is set from wrapped exception":function(){var a=Error("oshit"),b=a.message;this.assertEqual(this.Sut(a).message,
a.message);return b},"Throws exception if no exception is wrapped":function(){var a=this.Sut;this.assertThrows(function(){a()},TypeError);this.assertThrows(function(){a("not an exception")},TypeError)},"Can retrieve wrapped exception":function(){var a=Error("foo"),b=this.Sut(a);this.assertStrictEqual(a,b.getError())}})})(g["test/warn/WarningTest"]={},"test/warn")};D.Class=g["class"].exports;D.AbstractClass=g.class_abstract.exports;D.FinalClass=g.class_final.exports;D.Interface=g["interface"].exports;
D.Trait=g.Trait.exports;D.version=g.version.exports})(easejs,".");
